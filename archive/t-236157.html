<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="keywords" content=" Find file in a list of paths, media player, mp3 player, music player, ipod sync, multimedia player, player, winamp, audio player" />
	<meta name="description" content="[Archive]  Find file in a list of paths NSIS Discussion" />
	
	<title> Find file in a list of paths [Archive]  - Winamp Forums</title>
	<link rel="stylesheet" type="text/css" href="archive.css" />
</head>
<body>
<div class="pagebody">
<div id="navbar">Winamp Forums &gt; Developer Center &gt; <a href="f-65.html">NSIS Discussion</a> &gt;  Find file in a list of paths</div>
<hr />
<div class="pda"><a href="t-236157.html?login=1" rel="nofollow">Log in</a></div>
<p class="largefont">Try the Internet Archive: <a href="http://web.archive.org/web/*/forums.winamp.com/showthread.php?t=236157">Find file in a list of paths</a></p>
<hr />

<div class="post"><div class="posttop"><div class="username">mjs</div><div class="date">22nd January 2006, 19:29</div></div><div class="posttext">Hi,<br />
<br />
I had the problem that I had to find a file in a list of paths. My solution requires the &quot;IndexOf&quot; implementation from the Wiki.<br />
<br />
Here's the source. Any suggestions?<br />
<br />
Function IndexOfAny<br />
  Exch $R0<br />
  Exch<br />
  Exch $R1<br />
  Push $R2<br />
  Push $R3<br />
  Push $R4<br />
  Push $R5<br />
  Push $R6<br />
  StrCpy $R5 -1<br />
  StrCpy $R6 0<br />
  StrLen $R3 $R1<br />
NextChar:<br />
    IntCmp $R3 0 NotFound<br />
    IntOp $R3 $R3 - 1<br />
    StrCpy $R4 $R1 1 $R3<br />
    ${IndexOf} $R2 $R0 $R4<br />
    IntCmp $R2 -1 NextChar<br />
    IntCmp $R6 0 ForceSet<br />
    IntCmp $R5 $R2 NextChar NextChar 0<br />
ForceSet:<br />
      StrCpy $R5 $R2<br />
      StrCpy $R6 1<br />
  GoTo NextChar<br />
NotFound:<br />
  StrCpy $R0 $R5<br />
  Pop $R6<br />
  Pop $R5<br />
  Pop $R4<br />
  Pop $R3<br />
  Pop $R2<br />
  Pop $R1<br />
  Exch $R0<br />
FunctionEnd<br />
<br />
!macro IndexOfAny Var Str Chars<br />
  Push &quot;${Chars}&quot;<br />
  Push &quot;${Str}&quot;<br />
    Call IndexOfAny<br />
  Pop &quot;${Var}&quot;<br />
!macroend<br />
!define IndexOfAny &quot;!insertmacro IndexOfAny&quot;<br />
<br />
; IN: Path list<br />
; OUT: Remaining path list<br />
;      Path entry<br />
Function ExtractPathFromList<br />
  Exch $R0<br />
  Push $R1 ; Index of found delimiter<br />
  Push $R2 ; Found path entry<br />
  Push $R3 ; Remaining path entries<br />
  Push $R4 ; Found character<br />
  Push $R5<br />
  Push $R6<br />
  Push $R7<br />
  Push $R8<br />
<br />
  StrCpy $R7 '&quot; '<br />
  StrCpy $R8 '&quot;'<br />
<br />
  StrCpy $R2 &quot;&quot;<br />
  StrCpy $R3 $R0<br />
<br />
CheckAgain:<br />
  ${IndexOfAny} $R1 $R3 $R7<br />
  IntCmp $R1 -1 ReturnRemaining<br />
<br />
    StrCpy $R4 $R3 1 $R1           ; Get found delimiter<br />
    StrCpy $R5 $R3 $R1             ; Get text until delimiter (excl.)<br />
    IntOp $R1 $R1 + 1<br />
    StrCpy $R3 $R3 &quot;&quot; $R1          ; Get remaining text<br />
    StrCpy $R2 &quot;$R2$R5&quot;            ; Combine with ...<br />
<br />
    StrCmp $R4 $R8 FoundQuote<br />
    GoTo Finished<br />
<br />
FoundQuote:<br />
    ${IndexOf} $R1 $R3 $R8<br />
    IntCmp $R1 -1 ReturnRemaining<br />
<br />
    StrCpy $R4 $R3 1 $R1           ; Get found delimiter<br />
    StrCpy $R5 $R3 $R1             ; Get text until delimiter (excl.)<br />
    IntOp $R1 $R1 + 1<br />
    StrCpy $R3 $R3 &quot;&quot; $R1          ; Get remaining text<br />
    StrCpy $R2 &quot;$R2$R5&quot;<br />
    GoTo CheckAgain<br />
<br />
ReturnRemaining:<br />
  StrCpy $R2 $R0<br />
  StrCpy $R3 &quot;&quot;<br />
<br />
Finished:<br />
  StrCpy $R1 $R2<br />
  StrCpy $R0 $R3<br />
<br />
  Pop $R8<br />
  Pop $R7<br />
  Pop $R6<br />
  Pop $R5<br />
  Pop $R4<br />
  Pop $R3<br />
  Pop $R2<br />
  Exch $R1<br />
  Exch<br />
  Exch $R0<br />
FunctionEnd<br />
<br />
!macro ExtractPathFromList VarEntry VarRemaining Paths<br />
  Push '${Paths}'<br />
    Call ExtractPathFromList<br />
  Pop &quot;${VarRemaining}&quot;<br />
  Pop &quot;${VarEntry}&quot;<br />
!macroend<br />
!define ExtractPathFromList &quot;!insertmacro ExtractPathFromList&quot;<br />
<br />
; IN:  Paths<br />
;      File name<br />
; OUT: Path+FileName<br />
Function FindFileInPaths<br />
  Exch $R0<br />
  Exch<br />
  Exch $R1<br />
  Push $R2<br />
  Push $R3<br />
<br />
check_next:<br />
  ${ExtractPathFromList} $R2 $R1 $R1<br />
  StrCmp $R2 &quot;&quot; not_found<br />
<br />
  StrCpy $R2 &quot;$R2\$R0&quot;<br />
  IfFileExists &quot;$R2&quot; 0 check_next<br />
<br />
  StrCpy $R0 $R2<br />
  GoTo finished<br />
<br />
not_found:<br />
  StrCpy $R0 &quot;&quot;<br />
<br />
finished:<br />
  Pop $R3<br />
  Pop $R2<br />
  Pop $R1<br />
  Exch $R0<br />
FunctionEnd<br />
<br />
!macro FindFileInPaths Var FileName Paths<br />
  Push '${Paths}'<br />
  Push &quot;${FileName}&quot;<br />
    Call FindFileInPaths<br />
  Pop &quot;${Var}&quot;<br />
!macroend<br />
!define FindFileInPaths &quot;!insertmacro FindFileInPaths&quot;<br />
<br />
<br />
The main idea is to implement an &quot;IndexOfAny&quot; which searches for the first occurrence of one of the given characters. The next step is to extract the first path from a &quot;list&quot; of paths that are divided by a SPC (ASCII 32) character. It also takes care of all quotation marks ('&quot;').<br />
<br />
Example usage:<br />
  ${FindFileInPaths} $R0 &quot;hh.exe&quot; 'C:\WINDOWS C:\ &quot;C:\Program Files&quot;'<br />
  MessageBox MB_OK $R0<br />
<br />
<br />
This is my first NSIS script *g*.<br />
<br />
Regards,<br />
Mark</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Instructor</div><div class="date">22nd January 2006, 23:04</div></div><div class="posttext">Name &quot;Output&quot;<br />
OutFile &quot;Output.exe&quot;<br />
<br />
Section<br />
	locate::Open /NOUNLOAD &quot;C:\&quot; &quot;/D=0 /G=0 /N=file1.ext|file2.ext|file3.ext /P=C:\WINDOWS|C:\Program Files&quot; .r0<br />
	StrCmp $0 -1 0 loop<br />
	MessageBox MB_OK &quot;Error&quot; IDOK close<br />
<br />
	loop:<br />
	locate::Find /NOUNLOAD .r0 .r1 .r2 .r3 .r4 .r5<br />
	StrCmp $0 '' close<br />
<br />
	MessageBox MB_OKCANCEL '$$0    &quot;path\name&quot;   =[$0]$\n\<br />
					$$1    &quot;path&quot;             =[$1]$\n\<br />
					$$2    &quot;name&quot;           =[$2]$\n\<br />
					$$3    &quot;size&quot;             =[$3]$\n\<br />
					$$4    &quot;time&quot;             =[$4]$\n\<br />
					$$5    &quot;attributes      =[$5]$\n\<br />
									$\n\<br />
					Find next?' IDOK loop<br />
	close:<br />
	locate::Close<br />
SectionEndhttp://nsis.sourceforge.net/Locate_plugin</div></div><hr />


<div id="copyright">2001-2013 <a href="http://creativecommons.org/publicdomain/mark/1.0/" target="_blank">Public Domain Mark 1.0</a></div>
</div>
</body>
</html>