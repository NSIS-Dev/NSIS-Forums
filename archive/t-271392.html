<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="keywords" content=" Next free drive letter, media player, mp3 player, music player, ipod sync, multimedia player, player, winamp, audio player" />
	<meta name="description" content="[Archive]  Next free drive letter NSIS Discussion" />
	
	<title> Next free drive letter [Archive]  - Winamp Forums</title>
	<link rel="stylesheet" type="text/css" href="archive.css" />
</head>
<body>
<div class="pagebody">
<div id="navbar">Winamp Forums &gt; Developer Center &gt; <a href="f-65.html">NSIS Discussion</a> &gt;  Next free drive letter</div>
<hr />
<div class="pda"><a href="t-271392.html?login=1" rel="nofollow">Log in</a></div>
<p class="largefont">Try the Internet Archive: <a href="http://web.archive.org/web/*/forums.winamp.com/showthread.php?t=271392">Next free drive letter</a></p>
<hr />

<div class="post"><div class="posttop"><div class="username">Merlinovich</div><div class="date">18th May 2007, 22:50</div></div><div class="posttext">I need to add a network drive for the next available drive letter.<br />
<br />
I saw a post from Junior Member scatlin how to add drive Q: as a mapped network drive with the command<br />
Exec '&quot;net&quot; &quot;use&quot; &quot;Q:&quot; &quot;\\server\directory&quot; ...'<br />
<br />
However first I would like to *find* the next drive letter not in use. If I do it with Q: and the user has already mapped Q:, my user is in trouble (the installation will either overwrite what he has or abort, both of which are undesirable). I searched in the forum and help file of NSIS, but came up empty handed.<br />
<br />
I could perhaps use {GetDrives} with some tedious looping. But I don't want to reinvent the wheel ...</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Anders</div><div class="date">18th May 2007, 23:19</div></div><div class="posttext">&quot;net use * \\server\share&quot; will use the next free drive letter.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Merlinovich</div><div class="date">18th May 2007, 23:27</div></div><div class="posttext">Thanks, Anders! This works fine (kind of circumventing the problem) but now I need to know for the rest of my script which letter was assigned?</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">19th May 2007, 11:29</div></div><div class="posttext">What is the output of that command?<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Merlinovich</div><div class="date">19th May 2007, 14:28</div></div><div class="posttext">Here is a small part of my NSIS script:<br />
<br />
  Exec '&quot;net&quot; &quot;use&quot; &quot;*&quot; &quot;\\PM2000\ICIS5&quot;'<br />
...<br />
  ; Configure ODBC data source GMS Central<br />
  WriteRegStr HKCU &quot;Software\ODBC\ODBC.INI\ODBC Data Sources&quot; &quot;$Crop-CENTRAL-GMS&quot; &quot;Microsoft Access Driver (*.mdb)&quot;<br />
  WriteRegStr HKCU &quot;Software\ODBC\ODBC.INI\$Crop-CENTRAL-GMS&quot; &quot;DBQ&quot; &quot;X:\Database\$Crop\Central\$Crop-GMS.mdb&quot;<br />
  WriteRegStr HKCU &quot;Software\ODBC\ODBC.INI\$Crop-CENTRAL-GMS&quot; &quot;Driver&quot; &quot;$SYSDIR\odbcjt32.dll&quot;<br />
...<br />
<br />
I'm setting up ODBC data sources to point to the newly created mapped network drive.<br />
Now I would like to set X:\ to Q:\ above if Q:\ was the drive that was assigned in the net-command.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">19th May 2007, 14:31</div></div><div class="posttext">Like I said, does that command tell you anything when you execute it such as the drive that was mapped?<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Merlinovich</div><div class="date">19th May 2007, 15:46</div></div><div class="posttext">Oh, with &quot;that command&quot; you mean the &quot;net use&quot; command. Silly me. Didn't know the &quot;net use&quot; until I got it from scatlin and Anders. <br />
<br />
Here is some documentation from Microsoft though:<br />
<br />
http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/net_use.mspx?mfr=true<br />
http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/net_use.mspx?mfr=true<br />
<br />
As far as I can tell, there is no output from the command, e.g. telling me which drive letter was assigned. I can use a bare &quot;net use&quot; command to get a list of connected drives, but that NSIS' GetDrives can also do, and the problem with that is that the files in the new drive could be identical to files in for instance C:\ or D:\ also (same subdirectories), and my script should not mix up these instances.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">19th May 2007, 16:00</div></div><div class="posttext">I guess you could compare the old list of drives with the new list to find out which one was added.<br />
You could use NSISArray for that.<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">demiller9</div><div class="date">19th May 2007, 16:49</div></div><div class="posttext">Here's the output of the net command that Stu is asking for:C:\Documents and Settings\Owner&gt;net use * \\laptop\scc_d<br />
Drive Z: is now connected to \\laptop\scc_d.<br />
<br />
The command completed successfully.<br />
<br />
I should point out that drive letter Z was not the 'next free drive letter' available to my way of thinking - my system only uses C (hard drive) and D (CD-ROM).<br />
<br />
Don</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">20th May 2007, 11:43</div></div><div class="posttext">Thank you. Something like this should get it.<br />
<br />
<br />
nsExec::ExecToStack 'net use * &quot;\\PM2000\ICIS5&quot;'<br />
Pop $R0<br />
StrCpy $R0 $R0 2 6<br />
<br />
$R0 will contain Z:<br />
<br />
You might want to do some validation checks on it though (i.e. check that it isn't empty!)<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Merlinovich</div><div class="date">22nd May 2007, 16:12</div></div><div class="posttext">Thanks for the feedback. I could never get the command nsExec::ExecToStack 'net use * &quot;\\PM2000\ICIS5&quot;' to work nor my first attempt Exec '&quot;net&quot; &quot;use&quot; &quot;\\PM2000\ICIS5&quot; &quot;&gt;out.txt&quot;' where out.txt would be empty. Instead Exec '&quot;net&quot; &quot;use&quot; &quot;&gt;out.txt&quot;'  worked fine and produced a listing of drives as expected, but didn't help me of course.<br />
<br />
Instead I opted for the NSISArray solution that Stu outlined. Here is the solution for anyone interested (sorry if I goofed up some command, I'm a newbie to NSIS):<br />
<br />
<br />
  !include &quot;NSISArray.nsh&quot;<br />
  !include &quot;LogicLib.nsh&quot;<br />
  !include &quot;FileFunc.nsh&quot;<br />
  !include &quot;WordFunc.nsh&quot;<br />
  !include &quot;TextFunc.nsh&quot;<br />
  !insertmacro GetDrives<br />
  !insertmacro WordReplace<br />
  !insertmacro LineRead<br />
  Var /Global MappedDrive<br />
  ${Array} &quot;MyArray&quot; 30 50<br />
  ${ArrayFunc} Write<br />
  ${ArrayFunc} Read<br />
...<br />
  ; Assign a mapped drive from \\PM2000\ICIS5<br />
  ; automatically and put that in ODBC sources<br />
  ; If it couldn't be assigned, then C:\ICIS5\... will be used<br />
  StrCpy $MappedDrive &quot;C:\ICIS5&quot;<br />
  ; Check first if it was already assigned to some network<br />
  ; drive, then recover that<br />
  ${GetDrives} &quot;NET&quot; &quot;RecoverMappedDrive&quot;<br />
  ; It wasn't found, so try to add it, recovering which<br />
  ; drive letter was assigned<br />
  ${If} $MappedDrive == &quot;C:\ICIS5&quot;<br />
     ${MyArray-&gt;Init}<br />
     StrCpy $R1 0<br />
     ${GetDrives} &quot;NET&quot; &quot;SaveMappedDrives&quot;<br />
     ExecWait '&quot;net&quot; &quot;use&quot; &quot;*&quot; &quot;\\PM2000\ICIS5&quot; &quot;/persistent:yes&quot;'<br />
     StrCpy $R1 0<br />
     ${GetDrives} &quot;NET&quot; &quot;GetMappedDriveLetter&quot;<br />
     ${MyArray-&gt;Delete}<br />
  ${EndIf}<br />
  ; Use of MappedDrive, which will either contain X: or C:\ICIS5<br />
  WriteRegStr HKCU &quot;Software\ODBC\ODBC.INI\$Crop-CENTRAL-GMS&quot; &quot;DBQ&quot; \<br />
  &quot;$MappedDrive\Database\$Crop\Central\$Crop-GMS.mdb&quot;<br />
SectionEnd<br />
<br />
; Check if X:\EXES\ICIS32.DLL exists (which it will if the<br />
; network directory was already mapped to X: )<br />
Function RecoverMappedDrive<br />
  IfFileExists $9EXES\ICIS32.DLL 0 +3<br />
     StrCpy $MappedDrive $9 1<br />
     StrCpy $MappedDrive &quot;$MappedDrive:&quot;<br />
  Push $0<br />
FunctionEnd<br />
<br />
Function SaveMappedDrives<br />
  ${MyArray-&gt;Write} $R1 $9<br />
  IntOp $R1 $R1 + 1<br />
  Push $0<br />
FunctionEnd<br />
<br />
Function GetMappedDriveLetter<br />
  ${MyArray-&gt;Read} $R2 $R1<br />
  IntOp $R1 $R1 + 1<br />
  ${If} $MappedDrive == &quot;C:\ICIS5&quot;<br />
     StrCmp $9 $R2 +3 0<br />
        StrCpy $MappedDrive $9 1<br />
        StrCpy $MappedDrive &quot;$MappedDrive:&quot;<br />
  ${EndIf}<br />
  Push $0<br />
FunctionEnd</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">22nd May 2007, 18:01</div></div><div class="posttext">I'm sorry, this code works much better :p<br />
<br />
<br />
ReadEnvStr $R0 COMSPEC<br />
nsExec::ExecToStack '$R0 /C net use * &quot;\\PC-01\Drive-C\NewPCTemp&quot;'<br />
Pop $R0<br />
<br />
StrCmp $R0 0 +4<br />
  Pop $R0<br />
  DetailPrint $R0<br />
  Abort<br />
<br />
Pop $R0<br />
StrCpy $MappedDrive $R0 2 6<br />
<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Merlinovich</div><div class="date">22nd May 2007, 18:13</div></div><div class="posttext">There might still be a problem with the exact location of the drive in the string, when using e.g. Spanish Windows or another regional Windows version. Perhaps this can be mended best by searching for ':' in the string, because that probably is independent of region (well, don't know about chinese!), so the drive letter will be just before ':'.<br />
<br />
Thanks for the alternative. My solution had the added benefit of introducing me to NSISarray that I think will be very useful for me in the future.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">22nd May 2007, 18:38</div></div><div class="posttext">Good point. Let me see what I can do.<br />
I just think the other solution is a bit dodgy because it's not direct.<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">22nd May 2007, 18:44</div></div><div class="posttext">Here we are.<br />
<br />
ReadEnvStr $R0 COMSPEC<br />
nsExec::ExecToStack '$R0 /C net use * &quot;\\PC-01\Drive-C\NewPCTemp&quot;'<br />
Pop $R0<br />
<br />
StrCmp $R0 0 +4<br />
  Pop $R0<br />
  DetailPrint $R0<br />
  Abort<br />
<br />
Pop $R0<br />
StrCpy $R1 0<br />
StrLen $R3 $R0<br />
<br />
StrCpy $R2 $R0 1 $R1<br />
StrCmp $R1 $R3 0 +3<br />
  DetailPrint &quot;Error: Mapped network drive could not be located.&quot;<br />
  Abort<br />
IntOp $R1 $R1 + 1<br />
StrCmp $R2 : 0 -5<br />
IntOp $R1 $R1 - 2<br />
<br />
StrCpy $MappedDrive $R0 2 $R1<br />
<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">bnicer</div><div class="date">23rd May 2007, 15:29</div></div><div class="posttext">Wow! Is there nothing NSIS can't do? Returning the output from a command prompt! I've used comspec, command.com and cmd.exe in vbScript. So I hope this isn't wrong. All credit goes to Stu for the solution. I noticed with cmd.exe the /c switch halts the script, and since you're running the commandline via another process, I don't know if you need to close the dos box. It may not even open. I also tried comspec with /k which is supposed to keep the window open and it doesn't.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">23rd May 2007, 15:34</div></div><div class="posttext">nsExec hides the command prompt window and it has to wait for the execution to complete to get the exit code and output.<br />
<br />
This code will work if the output contains unicode characters as well.<br />
<br />
%COMSPEC% is what you should use because command prompt can be cmd.exe or command.com depending on the operating system. <br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Merlinovich</div><div class="date">24th May 2007, 05:43</div></div><div class="posttext">Yes, NSIS is versatile :)<br />
<br />
I tried your new code (Stu) and it works fine in my desktop computer, even with a Spanish Windows version. So just when I thought the discussion was over, I stumbled over a case where my old version would work better. Perhaps Stu's code can be mended too to handle this case:<br />
<br />
I was trying to install on a Linux machine (VMWare) that has Windows XP as a subsystem (don't know the right term), and that Windows subsystem didn't allow the connection to the network drive without (LAN) username and password. So my installation with Stu's code just failed, while the old code &quot;worked&quot; to my surprise, because the old DOS window would then ask for username and password from the command prompt, and entering these, in fact *did* connect the network drive.<br />
<br />
I realize the &quot;net use /username:&lt;&gt; /password:&lt;&gt;&quot; is possible, but then I only have this kind of problem in 5% of my company's computers, the rest will connect automatically, and then it would be tedious in the 95% of cases to ask the user for LAN username and password. One drawback to the DOS window is that it is a bit ugly and distracting user attention, looks non-professional.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">24th May 2007, 16:15</div></div><div class="posttext">If it fails then perhaps you could ask for a username and password (which you would have to write a small plugin for).<br />
<br />
I'll have a look at not using cmd.exe.<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">24th May 2007, 16:17</div></div><div class="posttext">Hmm it seems to be ok now I get 0 on success without using cmd.exe.<br />
<br />
<br />
nsExec::ExecToStack 'net use * &quot;\\PC-01\Drive-C\NewPCTempo&quot;'<br />
Pop $R0<br />
<br />
StrCmp $R0 0 +4<br />
  Pop $R0<br />
  DetailPrint $R0<br />
  Abort<br />
<br />
Pop $R0<br />
StrCpy $R1 0<br />
StrLen $R3 $R0<br />
<br />
StrCpy $R2 $R0 1 $R1<br />
StrCmp $R1 $R3 0 +3<br />
  DetailPrint &quot;Error: Mapped network drive could not be located.&quot;<br />
  Abort<br />
IntOp $R1 $R1 + 1<br />
StrCmp $R2 : 0 -5<br />
IntOp $R1 $R1 - 2<br />
<br />
StrCpy $MappedDrive $R0 2 $R1<br />
<br />
<br />
Stu</div></div><hr />


<div id="copyright">2001-2013 <a href="http://creativecommons.org/publicdomain/mark/1.0/" target="_blank">Public Domain Mark 1.0</a></div>
</div>
</body>
</html>