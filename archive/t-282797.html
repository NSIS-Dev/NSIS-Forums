<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="keywords" content=" problems inserting finish page, media player, mp3 player, music player, ipod sync, multimedia player, player, winamp, audio player" />
	<meta name="description" content="[Archive]  problems inserting finish page NSIS Discussion" />
	
	<title> problems inserting finish page [Archive]  - Winamp Forums</title>
	<link rel="stylesheet" type="text/css" href="archive.css" />
</head>
<body>
<div class="pagebody">
<div id="navbar">Winamp Forums &gt; Developer Center &gt; <a href="f-65.html">NSIS Discussion</a> &gt;  problems inserting finish page</div>
<hr />
<div class="pda"><a href="t-282797.html?login=1" rel="nofollow">Log in</a></div>
<p class="largefont">Try the Internet Archive: <a href="http://web.archive.org/web/*/forums.winamp.com/showthread.php?t=282797">problems inserting finish page</a></p>
<hr />

<div class="post"><div class="posttop"><div class="username">Shwetha</div><div class="date">7th December 2007, 11:06</div></div><div class="posttext">im encountering problems with insertng finish page.Im using this !insertmacro MUI_PAGE_FINISH macro code looks as below<br />
<br />
<br />
;--------------------------------<br />
;Modern UI Configuration<br />
<br />
    ; Show a warning when the user cancels the install<br />
  !define MUI_ABORTWARNING<br />
  ; I'm using some custom pages<br />
  !define MUI_CUSTOMPAGECOMMANDS<br />
  ; Show a finish page at the end of the installation<br />
  !define MUI_FINISHPAGE <br />
  ; Don't present the option to reboot the computer on the finish page<br />
  !define MUI_FINISHPAGE_NOREBOOTSUPPORT<br />
  ; The icon for the installer title bar and .exe file<br />
  !define MUI_ICON &quot;eclipse.ico&quot;<br />
  ; I've written a function that I want to be called when the user cancels the installation<br />
  !define MUI_CUSTOMFUNCTION_ABORT myOnAbort<br />
  ; Override the text on the Finish Page<br />
  !define MUI_FINISHPAGE_TITLE &quot;Installation Complete&quot;<br />
  !define MUI_FINISHPAGE_TEXT &quot;Survey has been queued for installation on the selected Palm devices.\r\n\r\nClick 'Finish,' then HotSync each device to complete publishing.&quot;<br />
<br />
;--------------------------------<br />
; Modern UI Pages (listed in order they will appear<br />
<br />
  ; file installation page (preps needed files)<br />
  !insertmacro MUI_PAGE_INSTFILES<br />
  ; custom page for choosing the Palm user(s) to publish to<br />
   Page custom ShowUserList LeaveCustom<br />
  ;Page custom ShowUserList<br />
  ; this will be called before the finish page is displayed to perform cleanup<br />
  !define MUI_PAGE_CUSTOMFUNCTION_PRE myFinishPre<br />
  ; finish page<br />
  !insertmacro MUI_PAGE_FINISH<br />
 ;--------------------------------<br />
;Languages<br />
 <br />
  ; English only for now<br />
  !insertmacro MUI_LANGUAGE &quot;English&quot;<br />
<br />
;-------------------------------- <br />
<br />
when i run the installer only window with close and button pops up.How do i solve this problem</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Joel</div><div class="date">7th December 2007, 14:29</div></div><div class="posttext">Why do you have !insertmacro MUI_PAGE_FINISH twice?</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Shwetha</div><div class="date">10th December 2007, 04:34</div></div><div class="posttext">i have inserted only once which causes only the close window appear on the screen.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">10th December 2007, 10:57</div></div><div class="posttext">What is the close window?<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Shwetha</div><div class="date">14th December 2007, 12:27</div></div><div class="posttext">i meant to say that window pops up with close button in place of next button.How can i get the final finish page instead of this window?</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">14th December 2007, 15:52</div></div><div class="posttext">That is the finish page. Maybe you mean !define MUI_FINISHPAGE_NOAUTOCLOSE.<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Shwetha</div><div class="date">25th December 2007, 04:53</div></div><div class="posttext">after publishing page with finish button should appear on the screen indicating user to perform hotsync.But this is not happening in my application</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Shwetha</div><div class="date">25th December 2007, 11:42</div></div><div class="posttext">my script is as follows <br />
<br />
<br />
; declare variables<br />
Var PalmUserList  ; Used to dynamically populate dropdown on User Selection page<br />
Var UserChoice    ; Selected Palm Username<br />
Var InstallStatus ; Defined when the installer is aborting<br />
Var SurveyName    ; Survey full path from command line parameter<br />
Var StatPDB       ; full path of EpiSurveyor_stat.pdb<br />
Var PublishDir<br />
Var count<br />
Var isSelectAll<br />
Var userLists<br />
Var UserSelection<br />
Var HWND<br />
Var ChildSurveyName<br />
Var Survey<br />
Name &quot;Survey Publisher&quot; ;Display name for installer<br />
<br />
; declare macros<br />
!macro IndexOf Var Str Char<br />
   Push &quot;${Char}&quot;<br />
   Push &quot;${Str}&quot;<br />
   Call IndexOf<br />
   Pop &quot;${Var}&quot;<br />
!macroend<br />
!define IndexOf &quot;!insertmacro IndexOf&quot;<br />
<br />
!macro StrRep ResultVar String SubString RepString<br />
  Push &quot;${String}&quot;<br />
  Push &quot;${SubString}&quot;<br />
  Push &quot;${RepString}&quot;<br />
  Call StrRep<br />
  Pop &quot;${ResultVar}&quot;<br />
!macroend<br />
!define StrRep &quot;!insertmacro StrRep&quot;<br />
<br />
!include &quot;MUI.nsh&quot;<br />
!include &quot;LogicLib.nsh&quot;<br />
!include &quot;WinMessages.nsh&quot;<br />
<br />
;--------------------------------<br />
;Configuration<br />
  ; Name of the resulting executable installer file<br />
  OutFile &quot;publish.exe&quot;<br />
<br />
  ; I don't intend to install any files permenantly on the PC, so<br />
  ; use the system temporary directory<br />
  InstallDir &quot;$TEMP\EpiSurveyorSetup&quot;<br />
;--------------------------------<br />
;Modern UI Configuration<br />
<br />
 ; Show a license agreement page<br />
  !define MUI_LICENSEPAGE<br />
    ; Show a warning when the user cancels the install<br />
  !define MUI_ABORTWARNING<br />
  ; I'm using some custom pages<br />
  !define MUI_CUSTOMPAGECOMMANDS<br />
  ; Show a finish page at the end of the installation<br />
  !define MUI_FINISHPAGE<br />
  ; Don't present the option to reboot the computer on the finish page<br />
  !define MUI_FINISHPAGE_NOREBOOTSUPPORT<br />
  ; The icon for the installer title bar and .exe file<br />
  ;!define MUI_ICON &quot;eclipse.ico&quot;<br />
  ; I've written a function that I want to be called when the user cancels the installation<br />
  !define MUI_CUSTOMFUNCTION_ABORT myOnAbort<br />
  ; Override the text on the Finish Page<br />
  !define MUI_FINISHPAGE_TITLE &quot;Installation Complete&quot;<br />
  !define MUI_FINISHPAGE_TEXT &quot;Survey has been queued for installation on the selected Palm devices.\r\n\r\nClick 'Finish,' then HotSync each device to complete publishing.&quot;<br />
<br />
;--------------------------------<br />
; Modern UI Pages (listed in order they will appearance<br />
  ; file installation page (preps needed files)<br />
  !insertmacro MUI_PAGE_INSTFILES<br />
  ; custom page for choosing the Palm user(s) to publish to<br />
   Page custom ShowUserList LeaveCustom<br />
  !define MUI_WELCOMEFINISHPAGE_CUSTOMFUNCTION_INIT  DisableBackButton<br />
  ; this will be called before the finish page is displayed to perform cleanup<br />
  !define MUI_PAGE_CUSTOMFUNCTION_PRE myFinishPre<br />
  !insertmacro MUI_PAGE_FINISH<br />
   <br />
;--------------------------------<br />
;Languages<br />
  ; English only for now<br />
  !insertmacro MUI_LANGUAGE &quot;English&quot;<br />
<br />
;--------------------------------<br />
;Language Strings<br />
  ;Description text that I want to appear while files are being copied<br />
  LangString DESC_SecCopyUI ${LANG_ENGLISH} &quot;Copying the Palm files to your computer so they can be installed to your device.&quot;<br />
  ;Header text for all pages in the installer<br />
  LangString TEXT_IO_TITLE ${LANG_ENGLISH} &quot;EpiSurveyor&quot;<br />
  LangString TEXT_IO_SUBTITLE ${LANG_ENGLISH} &quot;Publish a survey to your devices&quot;<br />
<br />
;--------------------------------<br />
;Reserve Files<br />
<br />
  ;Things that need to be extracted first (keep these lines before any File command!)<br />
  ;Required for proper behavior when using BZIP2 compression<br />
  ReserveFile &quot;showUserList.ini&quot;<br />
  !insertmacro MUI_RESERVEFILE_INSTALLOPTIONS<br />
<br />
;--------------------------------<br />
;Installer Sections<br />
<br />
Section &quot;Prep for install&quot; SecCopyUI<br />
  ; get survey name from command line parameter<br />
  Push $R0<br />
  Call GetParameters<br />
  Pop $R0<br />
  ${StrRep} $R0 $R0 &quot;/&quot; &quot;\&quot;  ; replace slashes<br />
  StrCpy $SurveyName $R0<br />
  Loop:<br />
     ; loop until we have the index of the last slash<br />
    ${IndexOf} $R1 $R0 &quot;\&quot;<br />
     IntOp $0 $R1 + 1      ;advance index past the slash<br />
     StrCpy $R0 $R0 &quot;&quot; $0  ; $R0 now has first segment of path removed<br />
     StrCmp $R1 -1 LastToken Next<br />
     Next:<br />
     IntOp $R2 $R2 + $R1   ; sum of segments we've traversed found so far<br />
     IntOp $R2 $R2 + 1     ; add one for the slash<br />
     GoTo Loop<br />
  LastToken:<br />
  IntOp $3 $3 + 1<br />
  StrCpy $Survey $R0<br />
 ; MessageBox MB_OK|MB_ICONINFORMATION &quot;index = $R2&quot;<br />
  StrLen $1 $SurveyName<br />
 ; MessageBox MB_OK|MB_ICONINFORMATION &quot;path length = $1&quot;<br />
  IntOp $2 $R2 - $1   ; index minux length of string: negative to count back from end of string<br />
  ;MessageBox MB_OK|MB_ICONINFORMATION &quot;length of shortened path = $2&quot;<br />
  StrCpy $R3 $SurveyName $2<br />
 ; MessageBox MB_OK|MB_ICONINFORMATION &quot;value of R3 IS  $R3&quot;<br />
  StrCpy $PublishDir $R3<br />
 ;MessageBox MB_OK|MB_ICONINFORMATION &quot;publish dir is $PublishDir&quot;<br />
  StrCpy $StatPDB &quot;$R3EpiSurveyor_stat.pdb&quot;<br />
  SetOutPath &quot;$INSTDIR&quot;<br />
  ; Copy the files that we will use<br />
  File &quot;UserData.dll&quot;<br />
  File &quot;InstAide.dll&quot;<br />
 <br />
SectionEnd<br />
<br />
;--------------------------------<br />
;Descriptions<br />
<br />
!insertmacro MUI_FUNCTION_DESCRIPTION_BEGIN<br />
!insertmacro MUI_DESCRIPTION_TEXT ${SecCopyUI} $(DESC_SecCopyUI)<br />
!insertmacro MUI_FUNCTION_DESCRIPTION_END<br />
<br />
;--------------------------------<br />
;Installer Functions<br />
<br />
Function .onInit<br />
<br />
  ;Extract InstallOptions INI Files<br />
  !insertmacro MUI_INSTALLOPTIONS_EXTRACT_AS &quot;showUserList.ini&quot; &quot;showUserList.ini&quot;<br />
  !insertmacro MUI_INSTALLOPTIONS_EXTRACT &quot;showUserList.ini&quot;<br />
  !insertmacro MUI_INSTALLOPTIONS_EXTRACT &quot;installfiles.ini&quot;<br />
FunctionEnd<br />
<br />
; displays our custom &quot;Select Palm User&quot; page<br />
Function ShowUserList<br />
<br />
  Call GetPalmUserList<br />
  ; Use this list to populate the list on our custom page<br />
  !insertmacro MUI_INSTALLOPTIONS_WRITE &quot;showUserList.ini&quot; &quot;Field 2&quot; &quot;ListItems&quot; &quot;$PalmUserList&quot;<br />
  !insertmacro MUI_HEADER_TEXT &quot;$(TEXT_IO_TITLE)&quot; &quot;$(TEXT_IO_SUBTITLE)&quot;<br />
  !insertmacro MUI_INSTALLOPTIONS_INITDIALOG &quot;showUserList.ini&quot;<br />
  Pop $HWND<br />
  GetDlgItem $1 $HWNDPARENT 1<br />
  EnableWindow $1 0<br />
 <br />
  !insertmacro MUI_INSTALLOPTIONS_SHOW<br />
  Pop $0<br />
  InstallOptions::initDialog /NOUNLOAD &quot;$PLUGINSDIR\showUserList.ini&quot;<br />
  Call LeaveCustom<br />
  ; if we are aborting, do not check the value of UserChoice (if we do, then<br />
  ; if the user cancels the install without selecting a user, it will insist<br />
  ; that the user choose a user before exiting)<br />
   StrCmp $InstallStatus &quot;aborting_ir_install&quot; End 0<br />
    !insertmacro MUI_INSTALLOPTIONS_READ $UserChoice &quot;showUserList.ini&quot; &quot;Field 2&quot; &quot;State&quot;<br />
     StrCmp $isSelectAll &quot;1&quot; End<br />
     StrCmp $isSelectAll &quot;0&quot; End<br />
    ; Verify that the user chose a valid user.  If not, display the ShowUserList<br />
    ; screen again.<br />
    ; Why not simply set MinLen of the dropdown to 1?  This will prevent the user<br />
    ; from continuing without selecting a user, but it will not present any<br />
    ; messagebox or other dialog.  That is confusing to the user!<br />
      StrCmp $UserChoice &quot;&quot; 0 Continue<br />
      MessageBox MB_OK|MB_ICONINFORMATION &quot;You must choose at least one user to proceed.&quot;<br />
      Call ShowUserList<br />
      GoTo End<br />
      Continue:<br />
     ; MessageBox MB_OK|MB_ICONINFORMATION &quot;About to call InstallFiles function.&quot;<br />
      Call InstallFiles<br />
     ; MessageBox MB_OK|MB_ICONINFORMATION &quot;Just returned from InstallFiles function.&quot;<br />
  End:<br />
FunctionEnd<br />
<br />
Function LeaveCustom<br />
  ; At this point the user has either pressed Next or one of our custom buttons<br />
  ; We find out which by reading from the INI file<br />
  ReadINIStr $0 &quot;$PLUGINSDIR\showUserList.ini&quot; &quot;Settings&quot; &quot;State&quot;<br />
 !insertmacro MUI_INSTALLOPTIONS_READ $UserSelection &quot;showUserList.ini&quot; &quot;Field 2&quot; &quot;State&quot;<br />
  StrCmp $0 0 Done  ; Next button?<br />
  StrCmp $0 3 SelectAll  ; select all users<br />
  StrCmp $0 4 UnselectAll  ; unselect all users<br />
  ;added by shwetha on dec 07,2007<br />
  StrCmp $0 2 Selection<br />
  Abort ; Return to the page<br />
<br />
  SelectAll:<br />
   StrCpy $isSelectAll &quot;1&quot;<br />
   GetDlgItem $1 $HWNDPARENT 1<br />
   EnableWindow $1 1<br />
   GetDlgItem $1 $HWND 1203<br />
   EnableWindow $1 1<br />
  ;added on dec 04,2007<br />
   GetDlgItem $1 $HWND 1202<br />
   EnableWindow $1 0<br />
   GetDlgItem $1 $HWND 1201<br />
   SendMessage $1 ${LB_SELITEMRANGEEX} 0 $count<br />
   StrCpy $userLists $PalmUserList<br />
   Abort<br />
<br />
  UnselectAll:<br />
    GetDlgItem $0 $HWND 1201<br />
    SendMessage $1 ${LB_SETSEL} 0 -1<br />
    GetDlgItem $1 $HWNDPARENT 1<br />
    EnableWindow $1 0<br />
    StrCpy $isSelectAll &quot;0&quot;<br />
    GetDlgItem $1 $HWND 1203<br />
    EnableWindow $1 0<br />
    ;added on dec 04,2007<br />
    GetDlgItem $1 $HWND 1202<br />
    EnableWindow $1 1<br />
    StrCpy $userLists &quot;&quot;<br />
    Abort<br />
<br />
    Selection:<br />
    !insertmacro MUI_INSTALLOPTIONS_READ $UserSelection &quot;showUserList.ini&quot; &quot;Field 2&quot; &quot;State&quot;<br />
    StrCmp $UserSelection &quot;&quot; Disable<br />
    Disable:<br />
    GetDlgItem $1 $HWNDPARENT 1<br />
    EnableWindow $1 0<br />
    StrCmp $UserSelection &quot;&quot; End Cont<br />
    Cont:<br />
    GetDlgItem $1 $HWNDPARENT 1<br />
    EnableWindow $1 1<br />
    call InstallFiles<br />
    End:<br />
    Abort<br />
<br />
  Done:<br />
  StrCmp $isSelectAll 1 installAll<br />
  StrCmp $isSelectAll 0 next<br />
  StrCmp $UserChoice &quot;&quot; msg ; check if no users have been selected<br />
  installAll:<br />
  call InstallAllFiles<br />
  StrCpy $userLists &quot;&quot;<br />
  StrCmp $userLists &quot;&quot; msg<br />
  Abort<br />
  next:<br />
  StrCmp $UserChoice &quot;&quot; msg<br />
  StrCmp $isSelectAll &quot;&quot; msg<br />
  StrCmp $UserSelection &quot;&quot; msg<br />
  msg:<br />
  FunctionEnd<br />
  <br />
  Function InstallAllFiles<br />
 ; MessageBox MB_OK|MB_ICONINFORMATION &quot;Installing for all the users in progress....&quot;<br />
  ; ====================  INSTALL PRC/PDB FILES  ==========================<br />
  ; Set the PRC file to be installed to internal memory on next HotSync<br />
  StrCpy $1 $UserChoice<br />
      StrCpy $UserChoice $userLists  ;<br />
  Loop:<br />
     ${IndexOf} $R0 $UserChoice &quot;|&quot;<br />
     StrCpy $R3 $R0 ; if this was the last token $R3 will be -1 and we'll stop looping<br />
     StrCmp $R3 -1 LastToken Moveon<br />
     LastToken:<br />
     StrCpy $1 $UserChoice<br />
     Goto InstallSurveyPDB<br />
     Moveon:<br />
     StrCpy $1 $UserChoice $R0 ; $1 = first token<br />
     IntOp $R0 $R0 + 1<br />
     StrCpy $R2 $UserChoice &quot;&quot; $R0 ; R2 = new $UserChoice<br />
     StrCpy $UserChoice $R2<br />
<br />
     InstallSurveyPDB:<br />
     StrCpy $2 &quot;$SurveyName.pdb&quot;<br />
     ;MessageBox MB_OK|MB_ICONINFORMATION &quot;Installing $2 for user $1&quot;<br />
     System::Call 'InstAide::PltInstallFile(t r1, t r2) i .r3'<br />
     ;MessageBox MB_OK|MB_ICONINFORMATION &quot;Attempting install of $2 for user $1 PltInstallFile returned value of $3&quot;<br />
     StrCmp $3 &quot;-504&quot; +1 +3  ;ERR_PILOT_COPY_FAILED<br />
       ; MessageBox MB_OK|MB_ICONINFORMATION &quot;Copy Failed&quot;<br />
        Goto InstallOtherPDBs<br />
        StrCmp $3 &quot;-512&quot; +1 InstallOtherPDBs   ;ERR_PILOT_FILE_ALREADY_EXISTS<br />
       ;MessageBox MB_OK|MB_ICONINFORMATION &quot;Uninstalling $2 for user $1&quot;<br />
        System::Call 'InstAide::PltRemoveInstallFile(t r1, t r2) i .r3'<br />
        ;MessageBox MB_OK|MB_ICONINFORMATION &quot;PltRemoveInstallFile returned value of $3&quot;<br />
        System::Call 'InstAide::PltInstallFile(t r1, t r2) i .r3'<br />
        ;MessageBox MB_OK|MB_ICONINFORMATION &quot;PltInstallFile returned value of $3&quot;<br />
<br />
     InstallOtherPDBs:<br />
     StrCpy $2 &quot;$StatPDB&quot;<br />
     ;MessageBox MB_OK|MB_ICONINFORMATION &quot;Installing $2 for user $1&quot;<br />
     System::Call 'InstAide::PltInstallFile(t r1, t r2) i .r3'<br />
    ; MessageBox MB_OK|MB_ICONINFORMATION &quot;PltInstallFile returned value of $3&quot;<br />
     ; We don't care if there is one of these in the queue already, it'll do fine<br />
<br />
     StrCpy $2 &quot;$SurveyName_data.pdb&quot;<br />
    ; MessageBox MB_OK|MB_ICONINFORMATION &quot;Installing $2 for user $1&quot;<br />
     System::Call 'InstAide::PltInstallFile(t r1, t r2) i .r3'<br />
     ;MessageBox MB_OK|MB_ICONINFORMATION &quot;PltInstallFile returned value of $3&quot;<br />
     ; We don't care if there is one of these in the queue already, it'll do fine<br />
     Strcmp $count 0  End increment<br />
<br />
    increment:<br />
    IntOp $count $count - 1<br />
    Strcmp $count 0  End Loop<br />
    StrCmp $R3 -1 End Loop<br />
   ; StrCpy $userLists &quot;&quot;<br />
    End:<br />
  ; ====================  SHOW CUSTOM PAGE  ==========================<br />
 ; !insertmacro MUI_HEADER_TEXT &quot;$(TEXT_IO_TITLE)&quot; &quot;$(TEXT_IO_SUBTITLE)&quot;<br />
  ;!insertmacro MUI_INSTALLOPTIONS_DISPLAY &quot;installfiles.ini&quot;<br />
 <br />
FunctionEnd<br />
<br />
Function InstallFiles<br />
<br />
  ; ====================  INSTALL PRC/PDB FILES  ==========================<br />
  ; Set the PRC file to be installed to internal memory on next HotSync<br />
  StrCpy $1 $UserChoice<br />
  <br />
  StrCpy $UserSelection &quot;$UserSelection|&quot;<br />
 Loop:<br />
     ${IndexOf} $R0 $UserSelection &quot;|&quot;<br />
     StrCpy $R3 $R0 ; if this was the last token $R3 will be -1 and we'll stop looping<br />
     StrCmp $R3 -1 LastToken Moveon<br />
     LastToken:<br />
     StrCpy $1 $UserSelection<br />
     Goto InstallSurveyPDB<br />
     Moveon:<br />
     StrCpy $1 $UserSelection $R0<br />
    ; MessageBox MB_OK|MB_ICONINFORMATION &quot;first user is  $1&quot;<br />
     IntOp $R0 $R0 + 1<br />
     ;StrCpy $R2 $UserChoice &quot;&quot; $R0 ; R2 = new $UserChoice<br />
     StrCpy $R2 $UserSelection &quot;&quot; $R0 ; R2 = new $UserChoice<br />
     ;MessageBox MB_OK|MB_ICONINFORMATION &quot;next  user is  $R2&quot;<br />
     StrCpy $UserSelection $R2<br />
<br />
     InstallSurveyPDB:<br />
    ; MessageBox MB_OK|MB_ICONINFORMATION &quot; inside InstallSurveyPDB&quot;<br />
     StrCpy $2 &quot;$SurveyName.pdb&quot;<br />
     ;MessageBox MB_OK|MB_ICONINFORMATION &quot;Installing $2 for user $1&quot;<br />
     System::Call 'InstAide::PltInstallFile(t r1, t r2) i .r3'<br />
     ;MessageBox MB_OK|MB_ICONINFORMATION &quot;Attempting install of $2 for user $1 PltInstallFile returned value of $3&quot;<br />
     StrCmp $3 &quot;-504&quot; +1 +3  ;ERR_PILOT_COPY_FAILED<br />
     ;MessageBox MB_OK|MB_ICONINFORMATION &quot;Copy Failed&quot;<br />
     Goto InstallOtherPDBs<br />
     StrCmp $3 &quot;-512&quot; +1 InstallOtherPDBs   ;ERR_PILOT_FILE_ALREADY_EXISTS<br />
      ; MessageBox MB_OK|MB_ICONINFORMATION &quot;Uninstalling $2 for user $1&quot;<br />
       System::Call 'InstAide::PltRemoveInstallFile(t r1, t r2) i .r3'<br />
       ;MessageBox MB_OK|MB_ICONINFORMATION &quot;PltRemoveInstallFile returned value of $3&quot;<br />
       System::Call 'InstAide::PltInstallFile(t r1, t r2) i .r3'<br />
       ;MessageBox MB_OK|MB_ICONINFORMATION &quot;PltInstallFile returned value of $3&quot;<br />
<br />
     InstallOtherPDBs:<br />
    ;MessageBox MB_OK|MB_ICONINFORMATION &quot; inside InstallotherPDB&quot;<br />
     StrCpy $2 &quot;$StatPDB&quot;<br />
    ; MessageBox MB_OK|MB_ICONINFORMATION &quot;Installing $2 for user $1&quot;<br />
     System::Call 'InstAide::PltInstallFile(t r1, t r2) i .r3'<br />
     ;MessageBox MB_OK|MB_ICONINFORMATION &quot;PltInstallFile returned value of $3&quot;<br />
     ; We don't care if there is one of these in the queue already, it'll do fine<br />
<br />
     StrCpy $2 &quot;$SurveyName_data.pdb&quot;<br />
     ;MessageBox MB_OK|MB_ICONINFORMATION &quot;Installing $2 for user $1&quot;<br />
     System::Call 'InstAide::PltInstallFile(t r1, t r2) i .r3'<br />
    ; MessageBox MB_OK|MB_ICONINFORMATION &quot;PltInstallFile returned value of $3&quot;<br />
     ; We don't care if there is one of these in the queue already, it'll do fine<br />
<br />
  StrCmp $R3 -1 AbortLoop Loop<br />
  AbortLoop:<br />
  ; ====================  SHOW CUSTOM PAGE  ==========================<br />
  ;!insertmacro MUI_HEADER_TEXT &quot;$(TEXT_IO_TITLE)&quot; &quot;$(TEXT_IO_SUBTITLE)&quot;<br />
  ;!insertmacro MUI_INSTALLOPTIONS_DISPLAY &quot;installfiles.ini&quot;<br />
FunctionEnd<br />
<br />
<br />
Function GetPalmUserList<br />
  ; NSIS has to be using the directory containing the dll for it to find it<br />
  SetOutPath &quot;$INSTDIR&quot;<br />
  File &quot;UserData.dll&quot; ; copy dll there<br />
  System::Call 'UserData::UmGetUserCount(v) i .r1'<br />
  ;MessageBox MB_OK|MB_ICONINFORMATION &quot;There seem to be $1 Palm users&quot;<br />
  ;added byy shwetha for retreiving the palm users count<br />
  StrCpy $count $1<br />
  ;added by shwetha ends here<br />
  IntCmp $1 0 0 0 foundInstaller ; if return value of PltGetUserCount is 0 or negative, then we can't continue<br />
  MessageBox MB_OK|MB_ICONINFORMATION &quot;No Palm Installer was found on your system.  The installation cannot complete.  Please ensure that the latest version of the Palm Desktop Software is installed on your computer before installing.&quot;<br />
  Abort<br />
  foundInstaller:<br />
<br />
  ; Compile the list of Palm Users<br />
  StrCpy $2 0 ; Initialize counter<br />
  StrCpy $PalmUserList &quot;&quot; ; Initialize list<br />
  Loop:<br />
  StrCpy $4 ${NSIS_MAX_STRLEN} ; $4 will tell the function the buffer length of $3<br />
  ; $3 will be set to the username of the user indexed by $2<br />
  System::Call 'UserData::UmGetUserID(i r2, *i r6r6) i .r5'<br />
  System::Call 'UserData::UmGetUserName(i r6, t .r3, *i r4) i .r5'<br />
  ;MessageBox MB_OK|MB_ICONINFORMATION &quot;User indexed at $2 has ID $6 and name $3&quot;<br />
  StrCpy $PalmUserList &quot;$PalmUserList$3|&quot;<br />
  IntOp $2 $2 + 1 ; Incriment the counter<br />
  IntCmp $2 $1 0 Loop 0<br />
<br />
FunctionEnd<br />
<br />
Function RemoveFiles<br />
  ; We need to Unload the dll so that it can be deleted<br />
  System::Call 'InstAide::PltGetUserCount(v) i .r1 ?u'<br />
  System::Call 'UserData::UmGetUserCount(v) i .r1 ?u'<br />
  ; I read somewhere that you should do this.  Don't know what it does<br />
  SetPluginUnload manual<br />
  System::Free 0<br />
  ; Remove all of the files<br />
  SetOutPath $TEMP<br />
  Delete &quot;$INSTDIR\InstAide.dll&quot;<br />
  Delete &quot;$INSTDIR\UserData.dll&quot;<br />
  SetOutPath $PublishDir<br />
  Delete &quot;$SurveyName.pdb&quot;<br />
  Delete &quot;$SurveyName_data.pdb&quot;<br />
  Delete &quot;$StatPDB&quot;<br />
  RMDir /r &quot;$INSTDIR&quot;<br />
FunctionEnd<br />
<br />
Function RemoveInstallFiles<br />
  ; Un-schedule the files for installation to internal memory<br />
  <br />
  StrCpy $1 $UserChoice ; pipe-delimited string containing usernames<br />
<br />
  Loop:<br />
     ; Search string for pipe to get a token<br />
     ${IndexOf} $R0 $UserChoice &quot;|&quot;<br />
     StrCpy $R3 $R0 ; if this was the last token $R3 will be -1 and we'll stop looping<br />
     StrCmp $R3 -1 LastToken Moveon<br />
       LastToken:<br />
       StrCpy $1 $UserChoice<br />
       Goto UnInstall<br />
     Moveon:<br />
     StrCpy $1 $UserChoice $R0 ; $1 = first token<br />
     IntOp $R0 $R0 + 1<br />
     StrCpy $R2 $UserChoice &quot;&quot; $R0 ; R2 = new $UserChoice<br />
     StrCpy $UserChoice $R2<br />
<br />
     UnInstall:<br />
     StrCpy $2 &quot;$SurveyName.pdb&quot;<br />
     ;MessageBox MB_OK|MB_ICONINFORMATION &quot;Uninstalling $2 for user $1&quot;<br />
     System::Call 'InstAide::PltRemoveInstallFile(t r1, t r2) i .r3'<br />
     ;MessageBox MB_OK|MB_ICONINFORMATION &quot;PltInstallFile returned value of $3&quot;<br />
<br />
     StrCpy $2 &quot;$SurveyName_data.pdb&quot;<br />
     ;MessageBox MB_OK|MB_ICONINFORMATION &quot;Installing $2 for user $1&quot;<br />
     System::Call 'InstAide::PltRemoveInstallFile(t r1, t r2) i .r3'<br />
     ;MessageBox MB_OK|MB_ICONINFORMATION &quot;PltInstallFile returned value of $3&quot;<br />
<br />
     StrCpy $2 &quot;$StatPDB&quot;<br />
     ;MessageBox MB_OK|MB_ICONINFORMATION &quot;Installing $2 for user $1&quot;<br />
     System::Call 'InstAide::PltRemoveInstallFile(t r1, t r2) i .r3'<br />
     ;MessageBox MB_OK|MB_ICONINFORMATION &quot;PltInstallFile returned value of $3&quot;<br />
<br />
  StrCmp $R3 -1 Continue Loop<br />
  Continue:<br />
FunctionEnd<br />
<br />
Function DisableBackButton<br />
     GetDlgItem $1 $HWNDPARENT 3<br />
     EnableWindow $1 0<br />
FunctionEnd<br />
<br />
Function myFinishPre<br />
   ;MessageBox MB_OK|MB_ICONINFORMATION &quot;myFinishPre about to remove files&quot;<br />
  ; Before we exit the installer, clean up all of the files that we copied<br />
  ; to the PC<br />
   MessageBox MB_OK|MB_ICONINFORMATION &quot;installation completed for $Survey&quot;<br />
  Call RemoveFiles<br />
FunctionEnd<br />
<br />
Function myOnAbort<br />
  ;MessageBox MB_OK|MB_ICONINFORMATION &quot;WE ARE ABORTING !!!&quot;<br />
  ; Let other parts of the installer know that we are aborting<br />
  StrCpy $InstallStatus &quot;aborting_ir_install&quot;<br />
  ; In case we've already scheduled files for installation on the next HotSync,<br />
  ; we should un-schedule them<br />
  Call RemoveInstallFiles<br />
  ; Clean up all of the files that we copied to the PC<br />
  Call RemoveFiles<br />
FunctionEnd<br />
<br />
Function IndexOf<br />
   Exch $R0<br />
   Exch<br />
   Exch $R1<br />
   Push $R2<br />
   Push $R3<br />
<br />
   StrCpy $R3 $R0<br />
   StrCpy $R0 -1<br />
   IntOp $R0 $R0 + 1<br />
   StrCpy $R2 $R3 1 $R0<br />
   StrCmp $R2 &quot;&quot; +2<br />
   StrCmp $R2 $R1 +2 -3<br />
<br />
   StrCpy $R0 -1<br />
<br />
   Pop $R3<br />
   Pop $R2<br />
   Pop $R1<br />
   Exch $R0<br />
FunctionEnd<br />
<br />
<br />
; GetParameters<br />
; input, none<br />
; output, top of stack (replaces, with e.g. whatever)<br />
; modifies no other variables.<br />
<br />
Function GetParameters<br />
<br />
   Push $R0<br />
   ; MessageBox MB_OK|MB_ICONINFORMATION &quot;survey $R0&quot;<br />
   Push $R1<br />
   Push $R2<br />
   Push $R3<br />
<br />
   StrCpy $R2 1<br />
   StrLen $R3 $CMDLINE<br />
   ;Check for quote or space<br />
   StrCpy $R0 $CMDLINE $R2<br />
   StrCmp $R0 '&quot;' 0 +3<br />
   StrCpy $R1 '&quot;'<br />
   Goto loop<br />
   StrCpy $R1 &quot; &quot;<br />
<br />
   loop:<br />
     IntOp $R2 $R2 + 1<br />
     StrCpy $R0 $CMDLINE 1 $R2<br />
     StrCmp $R0 $R1 get<br />
     StrCmp $R2 $R3 get<br />
     Goto loop<br />
<br />
   get:<br />
     IntOp $R2 $R2 + 1<br />
     StrCpy $R0 $CMDLINE 1 $R2<br />
     StrCmp $R0 &quot; &quot; get<br />
     StrCpy $R0 $CMDLINE &quot;&quot; $R2<br />
<br />
   Pop $R3<br />
   Pop $R2<br />
   Pop $R1<br />
   Exch $R0<br />
   ;MessageBox MB_OK|MB_ICONINFORMATION &quot;survey $R0&quot;<br />
FunctionEnd<br />
<br />
Function StrRep<br />
/*After this point:<br />
  ------------------------------------------<br />
  $R0 = RepString (input)<br />
  $R1 = SubString (input)<br />
  $R2 = String (input)<br />
  $R3 = RepStrLen (temp)<br />
  $R4 = SubStrLen (temp)<br />
  $R5 = StrLen (temp)<br />
  $R6 = StartCharPos (temp)<br />
  $R7 = TempStrL (temp)<br />
  $R8 = TempStrR (temp)*/<br />
<br />
  ;Get input from user<br />
  Exch $R0<br />
  Exch<br />
  Exch $R1<br />
  Exch<br />
  Exch 2<br />
  Exch $R2<br />
  Push $R3<br />
  Push $R4<br />
  Push $R5<br />
  Push $R6<br />
  Push $R7<br />
  Push $R8<br />
<br />
  ;Return &quot;String&quot; if &quot;SubString&quot; is &quot;&quot;<br />
  ${IfThen} $R1 == &quot;&quot; ${|} Goto Done ${|}<br />
<br />
  ;Get &quot;RepString&quot;, &quot;String&quot; and &quot;SubString&quot; length<br />
  StrLen $R3 $R0<br />
  StrLen $R4 $R1<br />
  StrLen $R5 $R2<br />
  ;Start &quot;StartCharPos&quot; counter<br />
  StrCpy $R6 0<br />
<br />
  ;Loop until &quot;SubString&quot; is found or &quot;String&quot; reaches its end<br />
  ${Do}<br />
    ;Remove everything before and after the searched part (&quot;TempStrL&quot;)<br />
    StrCpy $R7 $R2 $R4 $R6<br />
<br />
    ;Compare &quot;TempStrL&quot; with &quot;SubString&quot;<br />
    ${If} $R7 == $R1<br />
      ;Split &quot;String&quot; to replace the string wanted<br />
      StrCpy $R7 $R2 $R6 ;TempStrL<br />
<br />
      ;Calc: &quot;StartCharPos&quot; + &quot;SubStrLen&quot; = EndCharPos<br />
      IntOp $R8 $R6 + $R4<br />
<br />
      StrCpy $R8 $R2 &quot;&quot; $R8 ;TempStrR<br />
<br />
      ;Insert the new string between the two separated parts of &quot;String&quot;<br />
      StrCpy $R2 $R7$R0$R8<br />
      ;Now calculate the new &quot;StrLen&quot; and &quot;StartCharPos&quot;<br />
      StrLen $R5 $R2<br />
      IntOp $R6 $R6 + $R3<br />
      ${Continue}<br />
    ${EndIf}<br />
<br />
    ;If not &quot;SubString&quot;, this could be &quot;String&quot; end<br />
    ${IfThen} $R6 &gt;= $R5 ${|} ${ExitDo} ${|}<br />
    ;If not, continue the loop<br />
    IntOp $R6 $R6 + 1<br />
  ${Loop}<br />
<br />
  Done:<br />
<br />
  ;Return output to user<br />
  StrCpy $R0 $R2<br />
<br />
/*After this point:<br />
  ------------------------------------------<br />
  $R0 = ResultVar (output)*/<br />
<br />
  Pop $R8<br />
  Pop $R7<br />
  Pop $R6<br />
  Pop $R5<br />
  Pop $R4<br />
  Pop $R3<br />
  Pop $R2<br />
  Pop $R1<br />
  Exch $R0<br />
FunctionEnd</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Anders</div><div class="date">25th December 2007, 12:14</div></div><div class="posttext">how about attaching such a long script next time, or use pastebin</div></div><hr />


<div id="copyright">2001-2013 <a href="http://creativecommons.org/publicdomain/mark/1.0/" target="_blank">Public Domain Mark 1.0</a></div>
</div>
</body>
</html>