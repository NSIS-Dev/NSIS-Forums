<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="keywords" content=" System Plugin and netapi32, media player, mp3 player, music player, ipod sync, multimedia player, player, winamp, audio player" />
	<meta name="description" content="[Archive]  System Plugin and netapi32 NSIS Discussion" />
	
	<title> System Plugin and netapi32 [Archive]  - Winamp Forums</title>
	<link rel="stylesheet" type="text/css" href="archive.css" />
</head>
<body>
<div class="pagebody">
<div id="navbar">Winamp Forums &gt; Developer Center &gt; <a href="f-65.html">NSIS Discussion</a> &gt;  System Plugin and netapi32</div>
<hr />
<div class="pda"><a href="t-243303.html?login=1" rel="nofollow">Log in</a></div>
<p class="largefont">Try the Internet Archive: <a href="http://web.archive.org/web/*/forums.winamp.com/showthread.php?t=243303">System Plugin and netapi32</a></p>
<hr />

<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">12th April 2006, 21:46</div></div><div class="posttext">I have created a small tool that provides a GUI for gathering information in order to create a user account in Windows. I figured it would be a good idea to make direct API calls and get to understand how the system plugin works ... After going over the source of the UserManager plugin as well as several MSDN pages I am having trouble getting this to work.<br />
<br />
In the first part of my code I am using InstallOptionsEx in order to create the GUI then I gather all the info into variables (working part, not shown here). The second part however that is handling the user creation is not working:<br />
<br />
<br />
; I am using some default definitions straight out of Lmaccess.h<br />
!define UF_SCRIPT 0x000001<br />
!define UF_NORMAL_ACCOUNT 0x000200<br />
!define UF_DONT_EXPIRE_PASSWD 0x010000<br />
!define USER_PRIV_USER 0x000001<br />
<br />
; First I get the computername as ComputerNamePhysicalNetBIOS:<br />
System::Call 'kernel32.dll::GetComputerNameExW(i 4, w .r0, *i ${NSIS_MAX_STRLEN} r1) i.r2'<br />
StrCpy $TargetServerName &quot;\\$0&quot;<br />
<br />
; Then I am constructing the USER_INFO_1 structure<br />
StrCpy $1 &quot;$TargetServerName&quot;<br />
StrCpy $2 1<br />
StrCpy $R1 &quot;$UserName&quot;<br />
StrCpy $R2 &quot;$Password&quot;<br />
StrCpy $R3 ${USER_PRIV_USER}<br />
StrCpy $R4 &quot;$UserDescription&quot;<br />
System::Int64Op ${UF_SCRIPT} + ${UF_NORMAL_ACCOUNT}<br />
Pop $R5<br />
System::Int64Op $R5 + ${UF_DONT_EXPIRE_PASSWD}<br />
Pop $R5<br />
System::Call '*(w R1, w R2, i 0, i R3, n, w R4, i R5, n)i.s'<br />
Pop $R6<br />
<br />
; Then I call the NetAddUser function from netapi32.dll<br />
System::Call 'netapi32.dll::NetUserAdd(w r1, i 1, i R6, i.r3) i.r4 ?e'<br />
<br />
The above gives me error 997 (ERROR_IO_PENDING) and $4 gives me error 87 (INVALID_PARAMETER)<br />
If I make the call like this:<br />
<br />
System::Call 'netapi32.dll::NetUserAdd(w r1, i 1, *i R6, i.r3) i.r4 ?e'<br />
<br />
then I get error 997 (ERROR_IO_PENDING) and $4 gives me error 2202 (ERROR_BAD_USERNAME)<br />
<br />
Note that all the variables used have been declared. Also I am using some error checking to make sure that the username and password have correct lengths.<br />
<br />
Any help will be much appreciated ;)<br />
<br />
CF<br />
<br />
More info about the USER_INFO_1 structure can be found here (http://msdn.microsoft.com/library/default.asp?url=/library/en-us/netmgmt/netmgmt/user_info_1_str.asp)<br />
The NetUserAdd function is described here (http://msdn.microsoft.com/library/default.asp?url=/library/en-us/netmgmt/netmgmt/netuseradd.asp)</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">13th April 2006, 14:56</div></div><div class="posttext">Right ...<br />
Although I am allocating space for the structure I am not putting any data into it, silly me. However I am still getting the same error (997 - ERROR_IO_PENDING) when I use this code:<br />
<br />
!define UF_SCRIPT 0x000001<br />
!define UF_NORMAL_ACCOUNT 0x000200<br />
!define UF_DONT_EXPIRE_PASSWD 0x010000<br />
!define USER_PRIV_USER 0x000001<br />
System::Call 'kernel32.dll::GetComputerNameExW(i 4, w .r0, *i ${NSIS_MAX_STRLEN} r1) i.r2'<br />
StrCpy $TargetServerName &quot;\\$0&quot;<br />
StrCpy $1 &quot;$TargetServerName&quot;<br />
StrCpy $2 1<br />
StrCpy $R1 &quot;$UserName&quot;<br />
StrCpy $R2 &quot;$Password&quot;<br />
StrCpy $R3 ${USER_PRIV_USER}<br />
StrCpy $R4 &quot;$UserDescription&quot;<br />
System::Int64Op ${UF_SCRIPT} + ${UF_NORMAL_ACCOUNT}<br />
Pop $R5<br />
System::Int64Op $R5 + ${UF_DONT_EXPIRE_PASSWD}<br />
Pop $R5<br />
System::Call '*(w R1, w R2, n, i R3, n, w R4, i R5, n) i.s'<br />
Pop $R6<br />
System::Call '*$R6(w R1, w R2, n, i R3, n, w R4, i R5, n)'<br />
<br />
System::Call 'netapi32.dll::NetUserAdd(w r1, i 1, *i R6, i.r3) i.r4 ?e'<br />
As for the string values in the structure, they have to be unicode and I am not sure if setting them as 'w Rx' is the way to go ...<br />
<br />
Any ideas?<br />
Thanks in advance<br />
<br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">kichik</div><div class="date">14th April 2006, 11:34</div></div><div class="posttext">$R6 already contains the pointer to your buffer. You shouldn't pass it as a pointer or you'll get a pointer to the pointer. Use just `i` instead of `*i`. On the same issue, in the fourth parameter, you should use `*i` instead of `i`.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">14th April 2006, 11:51</div></div><div class="posttext">Thanks for the info kichik :)<br />
<br />
Is it sufficient to pass the LPWSTR values to the structure as  'w Rx' since they should be unicode?StrCpy R1 &quot;$UserName&quot;<br />
; ... and so on for R2,3,...<br />
!define strUSERINFO '(w, w, n, i, n, w, i, n) i'<br />
System::Call '*${strUSERINFO}(R1,R2,,R3,,R4,R5,).s'or should I create a buffer for each parameter, then feed the value in and then point to that buffer from within the structure?<br />
StrLen $9 &quot;$UserName&quot;<br />
IntOp $9 $9 + 1<br />
System::Call '*(&amp;w$9 &quot;$UserName&quot;)i.R1'	<br />
;... and so on for R2,3,...<br />
!define strUSERINFO '(i, i, n, i, n, i, i, n) i'<br />
System::Call '*${strUSERINFO}(R1,R2,,R3,,R4,R5,).s'<br />
Thanks in advance<br />
<br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">kichik</div><div class="date">14th April 2006, 11:56</div></div><div class="posttext">'w' should be good enough.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">14th April 2006, 12:27</div></div><div class="posttext">Hmmm ... Still error 997.<br />
Here is the part of the code that I am running:SetCompressor /SOLID lzma<br />
!include &quot;MUI.nsh&quot;<br />
!include &quot;LogicLib.nsh&quot;<br />
<br />
OutFile &quot;Test.exe&quot;<br />
InstallDir &quot;$TEMP&quot;<br />
<br />
Var &quot;UserFirstName&quot;<br />
Var &quot;UserLastName&quot;<br />
Var &quot;UserDescription&quot;<br />
Var &quot;UserName&quot;<br />
Var &quot;Password&quot;<br />
Var &quot;UnlimitedPass&quot;<br />
Var &quot;TargetServerName&quot;<br />
<br />
!define UF_SCRIPT                               0x000001<br />
!define UF_NORMAL_ACCOUNT                       0x000200<br />
!define UF_DONT_EXPIRE_PASSWD                   0x010000<br />
<br />
!define USER_PRIV_GUEST                         0x000000<br />
!define USER_PRIV_USER                          0x000001<br />
!define USER_PRIV_ADMIN                         0x000002<br />
<br />
Section -Boo<br />
SectionEnd<br />
<br />
Function .onInit<br />
StrCpy $UserFirstName &quot;First Name&quot;<br />
StrCpy $UserLastName &quot;Last Name&quot;<br />
StrCpy $UserDescription &quot;Long user description&quot;<br />
StrCpy $UserName &quot;TemplateUser&quot;<br />
StrCpy $Password &quot;123tgfdds&quot;<br />
StrCpy $UnlimitedPass 1<br />
Call GetServerName<br />
Call CreateNewUser<br />
MessageBox MB_OK|MB_ICONINFORMATION 'The Error Code from the NetAPI command was &quot;$0&quot; and got &quot;$3&quot; and &quot;$4&quot;'<br />
Quit<br />
FunctionEnd<br />
<br />
Function GetServerName<br />
System::Call 'kernel32.dll::GetComputerNameExW(i 4, w .r0, *i ${NSIS_MAX_STRLEN} r1) i.r2'<br />
${If} $2 = 1<br />
StrCpy $TargetServerName &quot;\\$0&quot;<br />
${Else}<br />
MessageBox MB_OK|MB_ICONSTOP 'Could not determine the computer name!$\nAborting...'<br />
Quit<br />
${EndIf}<br />
System::Free $0<br />
FunctionEnd<br />
<br />
Function CreateNewUser<br />
StrCpy $1 &quot;$TargetServerName&quot;<br />
StrCpy $2 1<br />
!define strUSERINFO '(w, w, n, i, n, w, i, n) i'<br />
StrCpy $R1 &quot;$UserName&quot;<br />
StrCpy $R2 &quot;$Password&quot;<br />
StrCpy $R3 ${USER_PRIV_USER}<br />
StrCpy $R4 &quot;$UserDescription&quot;<br />
System::Int64Op ${UF_SCRIPT} + ${UF_NORMAL_ACCOUNT}<br />
Pop $R5<br />
${If} $UnlimitedPass = 1<br />
System::Int64Op $R5 + ${UF_DONT_EXPIRE_PASSWD}<br />
Pop $R5<br />
${EndIf}<br />
System::Call '*${strUSERINFO}(R1,R2,,R3,,R4,R5,) i.s'<br />
Pop $R6<br />
System::Call '*$R6${strUSERINFO}(R1,R2,,R3,,R4,R5,)'<br />
System::Call 'netapi32.dll::NetUserAdd(w r1, i 1, i R6, *i.r3) i.r4 ?e'<br />
Pop $0<br />
FunctionEnd<br />
<br />
? :igor: <br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">kichik</div><div class="date">14th April 2006, 16:54</div></div><div class="posttext">According to MSDN, NetUserAdd doesn't set the last error. The documentation doesn't mention GetLastError. 997 means nothing. The real error is returned by the function itself and set to $4 in your script. 87, which is the real error code, is ERROR_INVALID_PARAMETER.<br />
<br />
The real problems is with the `n` in the structure definition. `n` is not a valid type, it's only a valid value. Replace it with `i` and it'll work.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">14th April 2006, 17:48</div></div><div class="posttext">:) It works!<br />
Thanks a lot kichik!<br />
Please add me to the (long) list of people that you made happy in this forum :D <br />
<br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">15th April 2006, 03:13</div></div><div class="posttext">Hmmm ...<br />
Adding the user and changing some data works but I am stuck when I try to add the user to a group.<br />
Here is the part that works:<br />
SetCompressor /SOLID lzma<br />
!include &quot;MUI.nsh&quot;<br />
!include &quot;LogicLib.nsh&quot;<br />
<br />
OutFile &quot;Test.exe&quot;<br />
InstallDir &quot;$TEMP&quot;<br />
<br />
Var &quot;UserFirstName&quot;<br />
Var &quot;UserLastName&quot;<br />
Var &quot;UserDescription&quot;<br />
Var &quot;UserName&quot;<br />
Var &quot;Password&quot;<br />
Var &quot;UnlimitedPass&quot;<br />
Var &quot;TargetServerName&quot;<br />
<br />
!define UF_SCRIPT                               0x000001<br />
!define UF_NORMAL_ACCOUNT                       0x000200<br />
!define UF_DONT_EXPIRE_PASSWD                   0x010000<br />
!define USER_PRIV_USER                          0x000001<br />
!define USER_TYPE_1				1<br />
!define USER_INFO_23				23<br />
!define USER_TYPE_1011				1011<br />
<br />
!define strUSER_TYPE_1 '(w,w,i,i,i,w,i,i)i'<br />
!define strUSER_TYPE_1011 '(w)i'<br />
<br />
Section -Boo<br />
SectionEnd<br />
<br />
Function .onInit<br />
StrCpy $UserFirstName &quot;First Name&quot;<br />
StrCpy $UserLastName &quot;Last Name&quot;<br />
StrCpy $UserDescription &quot;Long user description&quot;<br />
StrCpy $UserName &quot;TemplateUser&quot;<br />
StrCpy $Password &quot;123tgfdds&quot;<br />
StrCpy $UnlimitedPass 1<br />
Call GetServerName<br />
Call CreateNewUser<br />
Call SetUserFullName<br />
Quit<br />
FunctionEnd<br />
<br />
Function GetServerName<br />
System::Call 'kernel32.dll::GetComputerNameExW(i 4, w .r0, *i ${NSIS_MAX_STRLEN} r1) i.r2'<br />
${If} $2 = 1<br />
StrCpy $TargetServerName &quot;\\$0&quot;<br />
${Else}<br />
MessageBox MB_OK|MB_ICONSTOP 'Could not determine the computer name!$\nAborting...'<br />
Quit<br />
${EndIf}<br />
System::Free $0<br />
FunctionEnd<br />
<br />
Function CreateNewUser<br />
StrCpy $1 &quot;$TargetServerName&quot;<br />
StrCpy $2 ${USER_TYPE_1}<br />
StrCpy $R1 &quot;$UserName&quot;<br />
StrCpy $R2 &quot;$Password&quot;<br />
StrCpy $R3 ${USER_PRIV_USER}<br />
StrCpy $R4 &quot;$UserDescription&quot;<br />
System::Int64Op ${UF_SCRIPT} + ${UF_NORMAL_ACCOUNT}<br />
Pop $R5<br />
${If} $UnlimitedPass = 1<br />
System::Int64Op $R5 + ${UF_DONT_EXPIRE_PASSWD}<br />
Pop $R5<br />
${EndIf}<br />
System::Call '*${strUSER_TYPE_1}(R1,R2,n,R3,n,R4,R5,n) i.s'<br />
Pop $R6<br />
System::Call '*$R6${strUSER_TYPE_1}(R1,R2,,R3,,R4,R5,)'<br />
System::Call 'netapi32.dll::NetUserAdd(w r1, i r2, i R6, *i.r3) i.r4'<br />
FunctionEnd<br />
<br />
Function SetUserFullName<br />
StrCpy $1 &quot;$TargetServerName&quot;<br />
StrCpy $2 &quot;$UserName&quot;<br />
StrCpy $3 ${USER_TYPE_1011}<br />
StrCpy $R1 &quot;$UserFirstName $UserLastName&quot;<br />
System::Call '*${strUSER_INFO_1011}(R1)i.s'<br />
Pop $R2<br />
System::Call '*$R2${strUSER_INFO_1011}(R1)'<br />
System::Call 'netapi32.dll::NetUserSetInfo(w r1, w r2, i r3, i R2, *i.r4) i.r5'<br />
FunctionEnd<br />
I tried using the NetGroupAddUser (http://msdn.microsoft.com/library/en-us/netmgmt/netmgmt/netgroupadduser.asp) function I get error 2220 on $4 (Group Name Cannot be found) and I suspect that this function is only for domain groups (although you would expect a fancier name like AddUserToDomainGroup or something :D )<br />
Function AddUserToGroup<br />
StrCpy $1 &quot;$TargetServerName&quot;<br />
StrCpy $2 &quot;USERS&quot;<br />
StrCpy $3 &quot;$UserName&quot;<br />
System::Call 'netapi32.dll::NetGroupAddUser(w r1, w r2, w r3)i.r4'<br />
FunctionEnd<br />
Then I tried to use the NetLocalGroupAddMembers (http://msdn.microsoft.com/library/en-us/netmgmt/netmgmt/netlocalgroupaddmembers.asp) function. If I understand correctly, I need to allocate a buffer that will contain the LOCALGROUP_MEMBERS_INFO_0 (http://msdn.microsoft.com/library/default.asp?url=/library/en-us/netmgmt/netmgmt/localgroup_members_info_0_str.asp) structure, which in turn should contain the SID structure of the user-account ... To get the SID I would have to call the NetUserGetInfo (http://msdn.microsoft.com/library/en-us/netmgmt/netmgmt/netusergetinfo.asp?) function and allocate a buffer for the User_Info_23 (http://msdn.microsoft.com/library/en-us/netmgmt/netmgmt/user_info_23_str.asp) structure which in turn contains a pointer to the SID structure (and this should have been pre-allocated) :hang:<br />
Something like this:<br />
System::Call 'netapi32.dll::NetApiBufferAllocate(&amp;w${NSIS_MAX_STRLEN}, *i.R9)'<br />
System::Call '*(&amp;w${NSIS_MAX_STRLEN},&amp;w${NSIS_MAX_STRLEN},\<br />
  &amp;w${NSIS_MAX_STRLEN},&amp;i${NSIS_MAX_STRLEN},&amp;i${NSIS_MAX_STRLEN})i.R8'<br />
StrCpy $1 &quot;$TargetServerName&quot;<br />
StrCpy $2 &quot;$UserName&quot;<br />
StrCpy $3 ${USER_INFO_23}<br />
System::Call 'netapi32.dll::NetUserGetInfo(w r1, w r2, i r3, i R8)i.r4'<br />
System::Call '*$R8(w.R1,w.R2,w.R3,i.R4,i.R5)'<br />
System::Call '*$R9(w.R6)'<br />
MessageBox MB_OK|MB_ICONINFORMATION 'Got the following Information:$\n\<br />
  Username: &quot;$R1&quot;$\nFull Name: &quot;$R2&quot;$\n\<br />
  User Comment: &quot;$R3&quot;$\nUser Flags: &quot;$R4&quot;$\n\<br />
  User SID: &quot;$R5&quot;$\nStored SID &quot;$R6&quot;'<br />
System::Call 'netapi32.dll::NetApiBufferFree(i R9)'<br />
However R1-6 are filled with gibberish after running the above code...<br />
:igor: <br />
<br />
Any ideas?<br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">kichik</div><div class="date">15th April 2006, 08:44</div></div><div class="posttext">Your call to NetApiBufferAllocate is invalid. The ampersand prefix is only available on structures and should it be an integer anyway and not a wide string. The allocation of the USER_INFO_23 structure is redundant. NetUserGetInfo allocates it for you. For this, its last parameter must be a pointer and not just a simple integer pointing to your allocated structure.StrCpy $1 &quot;$TargetServerName&quot;<br />
StrCpy $2 &quot;$UserName&quot;<br />
<br />
System::Call 'netapi32::NetUserGetInfo(w r1, w r2, i 23, *i .R8) i.r4'<br />
System::Call '*$R8(w.R1,w.R2,w.R3,i.R4,i.R5)'<br />
<br />
System::Call 'netapi32::NetApiBufferFree(i R8)'<br />
<br />
DetailPrint $R1<br />
DetailPrint $R2<br />
DetailPrint $R3<br />
DetailPrint $R4<br />
DetailPrint $R5BTW, according to MSDN, USER_INFO_23 is only available on XP and above. You might want to use LOCALGROUP_MEMBERS_INFO_3 instead.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">15th April 2006, 12:45</div></div><div class="posttext">Makes sense ;) <br />
However I am still a bit confused.<br />
The reason I am using the USER_INFO_23 structure for the NetUserGetInfo is that this one points to an SID. The other option would be the USER_INFO_20 structure which points to an RID. In both cases your code gives me in R5 the buffer where the SID/RID is stored so I have to call<br />
System::Call '*$R5(i .R7)'to get the actual SID/RID out to $R7. In the case of the RIDs, I get the 4 last digits of a user's SID, and this number is different for different users.<br />
In the case of the SIDs, if I make the call as an 'i' the output is always the same for any user (1281). If I make the call as an 'l' then the output is different for different users. Which brings me to the real question (which explains in part why I was trying to allocate buffers with NetApiBufferAllocate as w) what is the format of the SID that I should expect? Does it matter, since I will feed it to the NetLocalGroupAddMembers function or should I first transform it somehow to a readable quantity?<br />
<br />
Isn't LOCAL_GROUPMEMBERS_INFO_3 (http://msdn.microsoft.com/library/default.asp?url=/library/en-us/netmgmt/netmgmt/localgroup_members_info_3_str.asp) supposed to be available only to XP etc clients? The only reason I was not going to use it is that it contains the information in the format &lt;DomainName&gt;\&lt;AccountName&gt;  and I assumed that it is used only in a domain and not on a single workstation ...<br />
<br />
Thanks for all the help by the way, without your comments I would have spent way much more time in this, probably to no good end ;) <br />
<br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">kichik</div><div class="date">15th April 2006, 13:13</div></div><div class="posttext">$R5 is a pointer to the SID, it's what you need. You don't want to dereference it. LOCALGROUP_MEMBERS_INFO_0 has only one member which is a pointer to a SID. You don't need to mess with the internals of the SID. All you need is the pointer.<br />
<br />
LOCAL_GROUPMEMBERS_INFO_3 is available on NT and 2000 as well as XP. It does seem to require a domain name, so it's probably not good enough. You find another way to get the user's SID. You can get the RID using USER_INFO_20 and assemble the SID on your own with GetSidIdentifierAuthority, AllocateAndInitializeSid, GetSidSubAuthority and GetSidSubAuthorityCount. Count the sub-authorities using GetSidSubAuthorityCount, get all of them using GetSidSubAuthority, get the authority identifier using GetSidIdentifierAuthority and allocate your new SID with the those authorities and the RID using AllocateAndInitializeSid.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">15th April 2006, 13:41</div></div><div class="posttext">I just saw your reply while I was going to write that I finally figured it out :)<br />
I'll get the code shaped up a bit and I'll post it here.<br />
<br />
kichik I appreciate all your help :)<br />
Thank you very very very much :D <br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">15th April 2006, 15:18</div></div><div class="posttext">After a lot of messing around with those netapi32 functions I managed to get them to work.<br />
Needless to say that without kichik's comments I would probably be still trying ...<br />
<br />
So here is the full story if anyone wants to use those in the future.<br />
<br />
Some background:<br />
I wanted to be able to create a user and specify parameters that were not used in the UserMgr plugin (http://nsis.sourceforge.net/UserMgr_plug-in) like making the password to not expire or prevent the user from changing it. In order to achieve this I had to use netapi32.dll and its functions (You can get all the info needed for the netapi32 functions through this (http://msdn.microsoft.com/library/default.asp?url=/library/en-us/netmgmt/netmgmt/network_management_structures.asp) MSDN page).<br />
<br />
Step 0 - define constants and variables<br />
Here are the constants that are used by the NetAPI functions that I am calling, along with some variables that you may or may not want to use:<br />
<br />
;Possible user flags<br />
!define UF_SCRIPT                               0x000001<br />
!define UF_ACCOUNTDISABLE                       0x000002<br />
!define UF_HOMEDIR_REQUIRED                     0x000008<br />
!define UF_LOCKOUT                              0x000010<br />
!define UF_PASSWD_NOTREQD                       0x000020<br />
!define UF_PASSWD_CANT_CHANGE                   0x000040<br />
!define UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED      0x000080<br />
!define UF_TEMP_DUPLICATE_ACCOUNT               0x000100<br />
!define UF_NORMAL_ACCOUNT                       0x000200<br />
!define UF_INTERDOMAIN_TRUST_ACCOUNT            0x000800<br />
!define UF_WORKSTATION_TRUST_ACCOUNT            0x001000<br />
!define UF_SERVER_TRUST_ACCOUNT                 0x002000<br />
!define UF_DONT_EXPIRE_PASSWD                   0x010000<br />
!define UF_MNS_LOGON_ACCOUNT                    0x020000<br />
!define UF_SMARTCARD_REQUIRED                   0x040000<br />
!define UF_TRUSTED_FOR_DELEGATION               0x080000<br />
!define UF_NOT_DELEGATED                        0x100000<br />
!define UF_USE_DES_KEY_ONLY                     0x200000<br />
!define UF_DONT_REQUIRE_PREAUTH                 0x400000<br />
!define UF_PASSWORD_EXPIRED                     0x800000<br />
<br />
; User Types<br />
!define USER_TYPE_1				1<br />
!define USER_TYPE_1011				1011<br />
<br />
; USER_INFO Types<br />
!define USER_INFO_23				23<br />
<br />
; Local Group levels<br />
!define LOCALGROUP_MEMBERS_INFO_0		0<br />
<br />
; User level of privilege<br />
!define USER_PRIV_GUEST				0x000000<br />
!define USER_PRIV_USER				0x000001<br />
!define USER_PRIV_ADMIN				0x000002<br />
<br />
; Structure Definitions<br />
!define strUSER_INFO_1 '(w,w,i,i,w,w,i,w)i'<br />
!define strUSER_INFO_1011 '(w)i'<br />
<br />
;Variables<br />
Var &quot;TargetServerName&quot;<br />
Var &quot;UserName&quot;<br />
Var &quot;UserPassword&quot;<br />
Var &quot;UserFirstName&quot;<br />
Var &quot;UserLastName&quot;<br />
Var &quot;UserComment&quot;<br />
Var &quot;MakeAdmin&quot;<br />
Var &quot;UnlimitedPass&quot;<br />
Step 1 - Get the computer name<br />
This step may be redundant since you can use a null name and then the local machine will be the target system. Here is a function that will get the computer name and will place it on the $TargetServerName variable (you need to include LogicLib.nsh for this):<br />
Function GetComputerNameAPI<br />
System::Call 'kernel32.dll::GetComputerNameExW(i 4, w .r0, *i ${NSIS_MAX_STRLEN} r1) i.r2'<br />
${If} $2 = 1<br />
StrCpy $TargetServerName &quot;\\$0&quot;<br />
${Else}<br />
System::Call &quot;kernel32.dll::GetComputerNameW(t .r0, *i ${NSIS_MAX_STRLEN} r1) i.r2&quot;<br />
${If} $2 = 1<br />
StrCpy $TargetServerName &quot;\\$0&quot;<br />
${Else}<br />
MessageBox MB_OK|MB_ICONSTOP 'Could not determine the computer name!$\nAborting...'<br />
Quit<br />
${EndIf}<br />
${EndIf}<br />
System::Free $0<br />
FunctionEnd<br />
Step 2 - Create the user<br />
In order to create the user we need to call the NetUserAdd (http://msdn.microsoft.com/library/default.asp?url=/library/en-us/netmgmt/netmgmt/netuseradd.asp) function which requires to generate at least a USER_INFO_1 (http://msdn.microsoft.com/library/en-us/netmgmt/netmgmt/user_info_1_str.asp) structure which will hold the user's information (Note that we could use the USER_INFO_3 (http://msdn.microsoft.com/library/en-us/netmgmt/netmgmt/user_info_3_str.asp) structure instead which contains a lot more information for the user). Here is the relevant code:<br />
Function CreateUserAPI<br />
StrCpy $1 &quot;$TargetServerName&quot;<br />
StrCpy $2 ${USER_TYPE_1}<br />
StrCpy $R1 &quot;$UserName&quot;<br />
StrCpy $R2 &quot;$UserPassword&quot;<br />
StrCpy $R3 ${USER_PRIV_USER}<br />
StrCpy $R4 &quot;$UserComment&quot;<br />
System::Int64Op ${UF_SCRIPT} + ${UF_NORMAL_ACCOUNT}<br />
Pop $R5<br />
${If} $UnlimitedPass = 1<br />
System::Int64Op $R5 + ${UF_DONT_EXPIRE_PASSWD}<br />
Pop $R5<br />
${EndIf}<br />
System::Call '*${strUSER_INFO_1}(R1,R2,n,R3,n,R4,R5,n) i.s'<br />
Pop $R6<br />
System::Call '*$R6${strUSER_INFO_1}(R1,R2,n,R3,n,R4,R5,n)'<br />
System::Call 'netapi32.dll::NetUserAdd(w r1, i r2, i R6, *i.r3) i.r4'<br />
System::Free $R6<br />
FunctionEnd<br />
Note that we can add more user flags (see Step 0) by adding them incrementally to $R5<br />
<br />
Step 3 - Set the user's first and last name<br />
To do this I will be using the NetUserSetInfo (http://msdn.microsoft.com/library/en-us/netmgmt/netmgmt/netusersetinfo.asp) function. There are quite a few things we can change with this function, but I will only alter the first and last name of the user (structure USER_TYPE_1011 (http://msdn.microsoft.com/library/en-us/netmgmt/netmgmt/user_info_1011_str.asp)). Here is the function:<br />
Function SetUserInfoAPI<br />
StrCpy $1 &quot;$TargetServerName&quot;<br />
StrCpy $2 &quot;$UserName&quot;<br />
StrCpy $3 ${USER_TYPE_1011}<br />
StrCpy $R1 &quot;$UserFirstName $UserLastName&quot;<br />
System::Call '*${strUSER_INFO_1011}(R1)i.s'<br />
Pop $R2<br />
System::Call '*$R2${strUSER_INFO_1011}(R1)'<br />
System::Call 'netapi32.dll::NetUserSetInfo(w r1, w r2, i r3, i R2, *i.r4) i.r5'<br />
System::Free $R2<br />
FunctionEnd<br />
Step 4 - Get the user's SID<br />
We need this in order to use it in Step 5 (see bellow)<br />
I will use the NetUserGetInfo (http://msdn.microsoft.com/library/en-us/netmgmt/netmgmt/netusergetinfo.asp) function to get the SID of the user that was just created in Step 3. The data will be fed to a USER_INFO_23 (http://msdn.microsoft.com/library/en-us/netmgmt/netmgmt/user_info_23_str.asp) structure. The SID will be kept at a buffer pointed to by R9 in the next function:<br />
Function GetUserInfoAPI<br />
StrCpy $1 &quot;$TargetServerName&quot;<br />
StrCpy $2 &quot;$UserName&quot;<br />
StrCpy $3 ${USER_INFO_23}<br />
System::Call 'netapi32::NetUserGetInfo(w r1, w r2, i r3, *i .R8) i.r4'<br />
System::Call '*$R8(w .R1, w .R2, w .R3, i .R4, i .R9)'<br />
System::Free $R8<br />
FunctionEnd<br />
Step 5 - Add the user to a group<br />
This will be done using the NetLocalGroupAddMembers (http://msdn.microsoft.com/library/en-us/netmgmt/netmgmt/netlocalgroupaddmembers.asp?frame=true) function using the SID from the previous step. I am using the $MakeAdmin variable (you have to set it to 1 in order to add the user to the admin group) to determine the group I will be adding the user to.<br />
Function AddUserToGroupAPI<br />
StrCpy $1 &quot;$TargetServerName&quot;<br />
${If} $MakeAdmin = 1<br />
StrCpy $2 &quot;Administrators&quot;<br />
${Else}<br />
StrCpy $2 &quot;Users&quot;<br />
${EndIf}<br />
StrCpy $3 ${LOCALGROUP_MEMBERS_INFO_0}<br />
System::Int64Op 1 * 0x000001<br />
Pop $4<br />
System::Call 'netapi32.dll::NetLocalGroupAddMembers(w r1, w r2, i r3, *i R9, i r4) i.r6'<br />
FunctionEnd<br />
That's it!<br />
You can call the functions from inside your code or make a continuous block of all the commands and get the user created.<br />
Also you can add some error checking for each function. In general if the NetAPIs succeed they return 0 to the relevant variable.<br />
<br />
I have to say this was a an excellent chance for me to dive into the system plugin and I really enjoyed the process :D <br />
<br />
Again a big 'thank you' to kichik for the directions ...<br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Anders</div><div class="date">15th April 2006, 15:42</div></div><div class="posttext">This is very handy info, would be great if you added a page in the wiki. <br />
One question; is it ok to use the strings &quot;Administrators&quot; and &quot;Users&quot; on non english systems?</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">15th April 2006, 15:52</div></div><div class="posttext">I'll gladly post a page in the wiki :)<br />
I am pretty sure that the strings &quot;Administrators&quot; and &quot;Users&quot; apply only to english systems. Where can I find their definitions for other languages?<br />
CF<br />
<br />
[Edit]<br />
I guess we could use NetLocalGroupEnum to get all the groups, place them in an array then use NetGroupGetInfo for each member of the array to get the name of the group along with the RID. Then based on the RID decide which is the Admin and which is the guest group ...</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">15th April 2006, 19:12</div></div><div class="posttext">Right ... Stuck again.<br />
I am trying to enumerate the groups on the local machine using the NetLocalGroupEnum function:<br />
Function NetLocalGroupEnumAPI<br />
!define LOCAL_GROUP_INFO_0	0<br />
StrCpy $1 &quot;$TargetServerName&quot;<br />
StrCpy $2 ${LOCAL_GROUP_INFO_0}<br />
System::Int64Op 1 * 0x000000<br />
Pop $R4<br />
System::Call 'netapi32.dll::NetLocalGroupEnum(w r1, i r2, *i .R1, i ${NSIS_MAX_STRLEN}, *i .R2, *i .R3, i R4)i .R5'<br />
System::Call '*$R1(w .R9)'<br />
DetailPrint $R1  ; the buffer holding the LOCAL_GROUP_INFO_0 structure<br />
DetailPrint $R2  ; number of entries that have been parsed<br />
DetailPrint $R3  ; total number of entries<br />
DetailPrint $R4  ; the resume handle<br />
DetailPrint $R9  ; the group name from $R1<br />
FunctionEnd<br />
According to MSDN (http://msdn.microsoft.com/library/default.asp?url=/library/en-us/netmgmt/netmgmt/netlocalgroupenum.asp) the handle should be 0 when we first call the function and then remain unchanged (?).<br />
Calling a second time the function gives the same group name  every time (since the handle doesn't change?)... And both $R2 and $R3 are the same, as if the function goes directly to the last member of the allocated array.<br />
<br />
:mad: <br />
<br />
CF<br />
<br />
[Edit]<br />
Or, if R1 points to an array of LOCAL_GROUP_INFO_0 structures, then would it be logical to get the first value out, count its length, advance to the next memory buffer ($R1 + lenght of value in $R1) then get out the second value etc?</div></div><hr />


<div class="post"><div class="posttop"><div class="username">kichik</div><div class="date">15th April 2006, 20:39</div></div><div class="posttext">It's better to use a well-known SID. There may be a lot of groups with the administrator in them.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">15th April 2006, 21:35</div></div><div class="posttext">True.<br />
Which brings me back to my previous question: How do I supply the SID? What format do I have to use? Basically I am looking at WinBuiltinUsersSid, WinBuiltinGuestsSid, WinBuiltinAdministratorsSid etc but I am not sure how to tell the netapi32 which one it is ...<br />
CF<br />
<br />
[Edit]<br />
What puzzles me is that NetLocalGroupAddMembers accepts the group name as LPCWSTR so I am not sure how to pass an SID instead or how to get a groupname if I know its SID</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">16th April 2006, 23:36</div></div><div class="posttext">You find another way to get the user's SID. You can get the RID using USER_INFO_20 and assemble the SID on your own with GetSidIdentifierAuthority, AllocateAndInitializeSid, GetSidSubAuthority and GetSidSubAuthorityCount. Count the sub-authorities using GetSidSubAuthorityCount, get all of them using GetSidSubAuthority, get the authority identifier using GetSidIdentifierAuthority and allocate your new SID with the those authorities and the RID using AllocateAndInitializeSid.<br />
There must be an easier way!<br />
I can't believe that pre-XP software devellopers had to go through ALL that just to figure out a user's SID!<br />
<br />
<br />
Anyway here are some more netapi32 functions:<br />
<br />
Use the NetUserDel API function to delete a user. More info here (http://msdn.microsoft.com/library/default.asp?url=/library/en-us/netmgmt/netmgmt/netuserdel.asp)<br />
Function NetUserDeleteAPI<br />
StrCpy $1 &quot;$TargetServerName&quot;<br />
StrCpy $2 &quot;$UserName&quot;<br />
System::Call 'netapi32.dll::NetUserDel(w r1, w r2)i.r3'<br />
FunctionEnd<br />
Use the NetLocalGroupDelMembers API function to delete a user from a group. More info here (http://msdn.microsoft.com/library/en-us/netmgmt/netmgmt/netlocalgroupdelmembers.asp)<br />
Function NetLocalGroupDelMembersAPI<br />
!define LOCALGROUP_MEMBERS_INFO_0	0<br />
StrCpy $1 &quot;$TargetServerName&quot;<br />
StrCpy $2 &quot;$GroupName&quot;<br />
StrCpy $3 ${LOCALGROUP_MEMBERS_INFO_0}<br />
; Need to call GetUserInfo first to get the SID of the user<br />
StrCpy $4 $UserSID<br />
System::Int64Op 1 * 0x000001<br />
Pop $5<br />
System::Call 'netapi32.dll::NetLocalGroupDelMembers(w r1, w r2, i r3, *i r4, i r5) i.r6'<br />
System::Free $4<br />
FunctionEnd<br />
Use the NetLocalGroupAdd function to add a new group. More info here (http://msdn.microsoft.com/library/en-us/netmgmt/netmgmt/netlocalgroupadd.asp)<br />
Function NetLocalGroupAddAPI<br />
!define LOCALGROUP_INFO_1	1<br />
!define strLOCALGROUP_INFO_1 '(w,w)i)'<br />
StrCpy $1 &quot;$TargetServerName&quot;<br />
StrCpy $2 ${LOCALGROUP_INFO_1}<br />
StrCpy $R1 &quot;$GroupName&quot;<br />
StrCpy $R2 &quot;$GroupDescription&quot;<br />
System::Call '*${strLOCALGROUP_INFO_1}(R1,R2)i.s'<br />
Pop $R3<br />
System::Call '*$R3${strLOCALGROUP_INFO_1}(R1,R2)'<br />
System::Call 'netapi32.dll::NetLocalGroupAdd(w r1, i r2, i R3, *i r4)i.r5'<br />
System::Free $R3<br />
FunctionEnd<br />
Use the NetLocalGroupDel API function to delete a group. More info here (http://msdn.microsoft.com/library/en-us/netmgmt/netmgmt/netlocalgroupdel.asp)<br />
Function NetLocalGroupDelAPI<br />
StrCpy $1 &quot;$TargetServerName&quot;<br />
StrCpy $2 &quot;$GroupName&quot;<br />
System::Call 'netapi32.dll::NetLocalGroupDel(w r1, w r2)i.r3'<br />
FunctionEnd<br />
Use the NetLocalGroupGetInfo API function to get info for a group. More infohere (http://msdn.microsoft.com/library/en-us/netmgmt/netmgmt/netlocalgroupgetinfo.asp)<br />
Function NetLocalGroupGetInfoAPI<br />
!define LOCALGROUP_MEMBERS_INFO_1	1<br />
StrCpy $1 &quot;$TargetServerName&quot;<br />
StrCpy $2 &quot;$GroupName&quot;<br />
StrCpy $3 ${LOCALGROUP_MEMBERS_INFO_1}<br />
System::Call 'netapi32.dll::NetLocalGroupGetInfo(w r1, w r2, i r3, *i.R3)i.r4'<br />
System::Call '*$R3(w .R1, w .R2)'<br />
StrCpy $GroupName $R1<br />
StrCpy $GroupComment $R2<br />
System::Free $R3<br />
FunctionEnd<br />
Use the NetLocalGroupSetInfo function to set the info for a group. More info here (http://msdn.microsoft.com/library/en-us/netmgmt/netmgmt/netlocalgroupsetinfo.asp)<br />
Function NetLocalGroupSetInfoAPI<br />
!define LOCALGROUP_INFO_1	1<br />
!define strLOCALGROUP_INFO_1 '(w,w)i)'<br />
StrCpy $1 &quot;$TargetServerName&quot;<br />
StrCpy $2 &quot;$GroupName&quot;<br />
StrCpy $3 ${LOCALGROUP_INFO_1}<br />
StrCpy $R1 &quot;$GroupName&quot;<br />
StrCpy $R2 &quot;$GroupDescription&quot;<br />
System::Call '*${strLOCALGROUP_INFO_1}(R1,R2)i.s'<br />
Pop $R3<br />
System::Call '*$R3${strLOCALGROUP_INFO_1}(R1,R2)'<br />
System::Call 'netapi32.dll::NetLocalGroupSetInfo(w r1, w r2, i r3, i R3, *i r4)i.r5'<br />
System::Free $R3<br />
FunctionEnd<br />
<br />
This IS addictive :D<br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">19th April 2006, 13:52</div></div><div class="posttext">Right ...<br />
I am trying to add the user that I created to a group without providing the actual group name, in order to avoid the localization of the name (assuming for example that a German version of windows will not have 'Administrators' but something else), I thought about enumerating the groups on the local machine and then try to get their SID. Once I have the SID I can compare it to the well-known ones and decide which group to use. In this way I can also avoid the problem of unicode characters as the group name will always be stored in a memory buffer and I can feed it directly to a netapi32 function. However I hit (yet) another obstacle trying to get the SIDs:<br />
!define LOCALGROUP_INFO_0 0<br />
!define POLICY_LOOKUP_NAMES 800<br />
!define strLSA_OBJECT_ATTRIBUTES '(i,i,w,i,i,i)i'<br />
!define strLSA_UNICODE_STRING '(i,i,w)i'<br />
<br />
System::Int64Op 1 * 0x000000<br />
Pop $R4<br />
; R1 buffer containing the array of group names<br />
; R2 number of entries that have been read<br />
; R3 total number of entries<br />
; R4 resume handle<br />
System::Call 'netapi32.dll::NetLocalGroupEnum(n,i${LOCALGROUP_INFO_0},*i.R1,i${NSIS_MAX_STRLEN},*i.R2, *i .R3,*i.R4)'<br />
; Pop one entry out to $R9<br />
System::Call '*$R1(wR9)'<br />
; open an LSA policy object in order to lookup the SID<br />
System::Call '*${strLSA_OBJECT_ATTRIBUTES}(0,n,n,0,n,n).s'<br />
Pop $R0<br />
System::Call '*$R0${strLSA_OBJECT_ATTRIBUTES}(0,n,n,0,n,n)'<br />
; get the Lsa handle to $R2<br />
System::Call 'advapi32::LsaOpenPolicy(n,iR0,i${POLICY_LOOKUP_NAMES},*i.R2) ?e'<br />
Pop $0<br />
StrCmp $0 0 +1 Error<br />
; Create an LSA_UNICODE_STRING array with the name to lookup its SID<br />
StrLen $1 $R9 ; get its length<br />
IntOp $2 $1 + 1<br />
IntOp $2 $2 * 2 ; max length<br />
System::Call '*${strLSA_UNICODE_STRING}(r1,r2,R9).s'<br />
Pop $R4<br />
System::Call '*$R4${strLSA_UNICODE_STRING}(r1,r2,R9)'<br />
; Call LsaLookupNames<br />
System::Call 'advapi32::LsaLookupNames(iR2,i1,iR4,*i.R5,*i.R6)?e'<br />
Pop $0<br />
System::Call 'advapi32::LsaNtStatusToWinError(i r0)i.R1' ; $0 is Lsa NTSTATUS error, $1 is Windows error code<br />
StrCmp $0 0 +1 Error<br />
...<br />
Error:The above code is not working.  The Lsa handle is allocated but the LsaLookupNames call returns error 126 (NTSTATUS) and 317 (Windows) both of which don't make sense.<br />
I suspect that the problem is in the way I define the LSA_UNICODE_STRING array but playing around with that didn't get me anywhere ...<br />
<br />
Any ideas?<br />
<br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">kichik</div><div class="date">19th April 2006, 14:27</div></div><div class="posttext">You can use LookupAccountSid to get the name from a SID. Here's an example. Don't forget to allocate a buffer, call the wide-string (Unicode) version and pass that buffer instead of putting the result in $0.# allocate SID_IDENTIFIER_AUTHORITY<br />
System::Call &quot;*(&amp;i1 0, &amp;i4 0, &amp;i1 5) i.r0&quot;<br />
<br />
# allocate SID<br />
System::Call &quot;advapi32::AllocateAndInitializeSid(i r0, i 2, i 32, i 545, i 0, i 0, i 0, i 0, i 0, i 0, *i .r1)&quot;<br />
<br />
# free SID_IDENTIFIER_AUTHORITY<br />
System::Free $0<br />
<br />
# debug, see that the right SID was created<br />
System::Call advapi32::ConvertSidToStringSid(ir1,*t.R0)<br />
DetailPrint $R0<br />
<br />
# use SID to look-up account name<br />
StrCpy $R0 ${NSIS_MAX_STRLEN}<br />
System::Call &quot;advapi32::LookupAccountSid(i 0, i r1, t .r0, *i R0, t .r2, *i R0, *i .r3)&quot;<br />
<br />
# free SID<br />
System::Call &quot;advapi32::FreeSid(i r1)&quot;<br />
<br />
# print result<br />
DetailPrint $0</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">19th April 2006, 14:35</div></div><div class="posttext">Much faster/smarter than my approach, as usual :)<br />
Thanks kichik!<br />
<br />
I am still interested however in understanding why the previous code does not work ...<br />
Any clues?<br />
<br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">kichik</div><div class="date">19th April 2006, 14:46</div></div><div class="posttext">I can't tell right now why the previous code wasn't working. Although I can give you a hint and say that 126 is not the error you're looking for. First off, it's not an NTSTATUS, it's a simple Windows error which means a module can't be found. The System plug-in always causes it while looking for the right module to load. You probably got 317, which means a message can't be found, because you tried converting the invalid NTSTATUS code.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">19th April 2006, 14:49</div></div><div class="posttext">Allright, I'll play around a bit more and try to figure it out Thanks again kichik :)<br />
<br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">22nd April 2006, 09:51</div></div><div class="posttext">Here are some more netapi32 functions:<br />
<br />
Group enumeration using NetLocalGroup Enum (http://msdn.microsoft.com/library/default.asp?url=/library/en-us/netmgmt/netmgmt/netlocalgroupenum.asp)!define LOCALGROUP_INFO_0 0<br />
StrCpy $1 &quot;$TargetServerName&quot; ; should be \\COMPUTERNAME<br />
StrCpy $2 ${LOCALGROUP_INFO_0}<br />
System::Int64Op 1 * 0x000000<br />
Pop $R3<br />
; R0 - Buffer holding group names<br />
; R1 - number of items enumerated<br />
; R2 - total number of groups<br />
; R3 - resume handle<br />
System::Call 'netapi32.dll::NetLocalGroupEnum(w r1, i r2, *i .R0, i ${NSIS_MAX_STRLEN}, *i .R1, *i .R2, *i .R3)'<br />
NSISArray::New /NOUNLOAD LocalGroups<br />
StrCpy $Counter 0<br />
FeedArray:<br />
${If} $Counter &lt; $R2<br />
System::Call '*$R0(w.R4)'<br />
NSISArray::Write /NOUNLOAD LocalGroups $Counter &quot;$R4&quot;<br />
IntOp $R0 $R0 + 4<br />
IntOp $Counter $Counter + 1<br />
Goto FeedArray<br />
${EndIf}<br />
NSISArray::SizeOf /NOUNLOAD LocalGroups<br />
Pop $0 ; compare it to $R2 (total number of elements in the memory)<br />
System::Call 'netapi32.dll::NetApiBufferFree($R0)'<br />
${EndIf}<br />
User enumeration using NetUser Enum (http://msdn.microsoft.com/library/default.asp?url=/library/en-us/netmgmt/netmgmt/netuserenum.asp)StrCpy $1 &quot;$TargetServerName&quot;<br />
StrCpy $2 0<br />
StrCpy $3 ${FILTER_NORMAL_ACCOUNT}<br />
System::Int64Op 1 * 0x000000<br />
Pop $R3<br />
System::Call 'netapi32::NetUserEnum(w r1, i r2, i r3, *i .R0, i ${NSIS_MAX_STRLEN}, *i .R1, *i .R2, *i .R3)'<br />
StrCpy $Counter 0<br />
${If} $Counter &lt; $R2<br />
System::Call '*$R0(w.R4)'<br />
NSISArray::Write /NOUNLOAD LocalUsers $Counter &quot;$R4&quot;<br />
IntOp $R0 $R0 + 4<br />
IntOp $Counter $Counter + 1<br />
Goto FeedArray<br />
${EndIf}<br />
NSISArray::SizeOf /NOUNLOAD LocalUsers<br />
Pop $0<br />
System::Call 'netapi32.dll::NetApiBufferFree($R0)'<br />
${EndIf}<br />
Following the previous suggestions by kichik here is a better way to add users to groups: instead of adding them to 'GroupName' which may not be localized, we can first grab the group's SID using a well-known SID and then add the user to that group. So 'Step 5' of the above instructions would become:<br />
<br />
Step 5 - Add user to a group using NetLocalGroupAddMembers (http://msdn.microsoft.com/library/en-us/netmgmt/netmgmt/netgroupadduser.asp)!define LOCALGROUP_MEMBERS_INFO_0 0<br />
; First get the group's SID<br />
; Well-known SIDs<br />
; Administrators S-1-5-32-544<br />
; Users S-1-5-32-545<br />
; Guests S-1-5-32-546<br />
; Power Users S-1-5-32-547<br />
; Define a variable $GroupID and set it to 544 for administrators, 454 for users etc<br />
System::Call &quot;*(&amp;i1 0, &amp;i4 0, &amp;i1 5) i.r0&quot;<br />
StrCpy $1 $GroupID<br />
System::Call &quot;advapi32::AllocateAndInitializeSid(i r0, i 2, i 32, i r1, i 0, i 0, i 0, i 0, i 0, i 0, *i .r2)&quot;<br />
System::Free $0<br />
System::Call advapi32::ConvertSidToStringSid(ir2,*t.R0)<br />
${If} $R0 != &quot;S-1-5-32-$GroupID&quot;<br />
; set some error flag here<br />
${EndIf}<br />
System::Call '*(&amp;w${NSIS_MAX_STRLEN})i.R4'<br />
StrCpy $R0 ${NSIS_MAX_STRLEN}<br />
System::Call &quot;advapi32::LookupAccountSidW(i 0, i r2, i R4, *i R0, t .r3, *i R0, *i .r4)&quot;<br />
; the memory buffer with the SID is at $R4<br />
System::Call &quot;advapi32::FreeSid(i r2)&quot;<br />
; Now add the user to a group<br />
StrCpy $1 &quot;$TargetServerName&quot;<br />
StrCpy $3 ${LOCALGROUP_MEMBERS_INFO_0}<br />
StrCpy $4 $UserSID ; taken from 'Step 4 - Get the user's SID'<br />
System::Int64Op 1 * 0x000001<br />
Pop $5<br />
System::Call 'netapi32.dll::NetLocalGroupAddMembers(w r1, i R4, i r3, *i r4, i r5) i.r6' ; if the function is successful $6 should be 0<br />
Note that since we are manipulating users on the local machine, $1 in all the above can be set to null (n) and then the localhost will be the target.<br />
<br />
:)<br />
<br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">4th June 2006, 01:10</div></div><div class="posttext">Added a (long) WIKI  page (http://nsis.sourceforge.net/User_Management_using_API_calls)<br />
:)<br />
<br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">TobbeSweden</div><div class="date">22nd January 2009, 11:59</div></div><div class="posttext">I'm trying to use the EnumerateUsers macro, but keep getting the following error:<br />
<br />
&quot;Could not place all the user accounts into an array!&quot;<br />
<br />
On closer inspection the macro does succeed in enumerating users, but NSISArray::SizeOf returns an empty string.<br />
<br />
What do you think could be wrong?<br />
<br />
This is how I use it (this is the full installer script):<br />
<br />
Name &quot;EnumUsrs&quot;<br />
OutFile &quot;EnumUsrs.exe&quot;<br />
<br />
!include NSISArray.nsh<br />
!include EnumerateUsers.nsh<br />
<br />
ShowInstDetails show<br />
Page instfiles<br />
<br />
Section &quot;&quot;<br />
    !insertmacro EnumerateUsers &quot;&quot; UserArray<br />
SectionEnd</div></div><hr />


<div class="post"><div class="posttop"><div class="username">TobbeSweden</div><div class="date">23rd January 2009, 13:18</div></div><div class="posttext">It looks like the problem is caused by a couple of bugs in the EnumerateUsers code.<br />
<br />
First the array is created without specifying any sizes. This is wrong.<br />
I propose the following instead:<br />
NSISArray::New /NOUNLOAD ${USER_ARRAY_NAME} 5 ${NSIS_MAX_STRLEN}<br />
<br />
Secondly, when getting the size of the array it's important to call 'pop' three times to get the number of elements in the array.<br />
Like this:<br />
NSISArray::SizeOf /NOUNLOAD ${USER_ARRAY_NAME}<br />
Pop $0<br />
Pop $0<br />
Pop $0<br />
StrCmp $0 $R2 +2 +1</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">23rd January 2009, 20:51</div></div><div class="posttext">Hi TobbeSweden, <br />
The API calls and the array code on the Wiki are quite old (2+ years now!).<br />
AfroUK has updated his plugin and shuffled things around, so the options that I was using probably don't work on the latest version. I haven't really changed anything since then so feel free to alter the code on the Wiki as you see fit, as long as it works :)<br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">TobbeSweden</div><div class="date">23rd January 2009, 21:00</div></div><div class="posttext">Heh. I don't know if my changes work with the latest version of NSIS or the plugins either... But it works with the versions I had installed when I wrote that :)</div></div><hr />


<div id="copyright">2001-2013 <a href="http://creativecommons.org/publicdomain/mark/1.0/" target="_blank">Public Domain Mark 1.0</a></div>
</div>
</body>
</html>