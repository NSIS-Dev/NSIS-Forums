<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="keywords" content=" Get hard disk number from drive letter, media player, mp3 player, music player, ipod sync, multimedia player, player, winamp, audio player" />
	<meta name="description" content="[Archive]  Get hard disk number from drive letter NSIS Discussion" />
	
	<title> Get hard disk number from drive letter [Archive]  - Winamp Forums</title>
	<link rel="stylesheet" type="text/css" href="archive.css" />
</head>
<body>
<div class="pagebody">
<div id="navbar">Winamp Forums &gt; Developer Center &gt; <a href="f-65.html">NSIS Discussion</a> &gt;  Get hard disk number from drive letter</div>
<hr />
<div class="pda"><a href="t-317579.html?login=1" rel="nofollow">Log in</a></div>
<p class="largefont">Try the Internet Archive: <a href="http://web.archive.org/web/*/forums.winamp.com/showthread.php?t=317579">Get hard disk number from drive letter</a></p>
<hr />

<div class="post"><div class="posttop"><div class="username">dougcvc</div><div class="date">8th March 2010, 13:55</div></div><div class="posttext">Hello, i am trying to work out the disk number (if you look in computer management &gt; disk management each disk has a number 0 ,1 ,etc assigned) from a drive letter. Is this possible in any way?<br />
<br />
This sample script gets the volume number (\Device\HarddiskVolume1) but its the disk number i need.<br />
<br />
Any suggestions would be great.<br />
<br />
<br />
!define name test<br />
!define version 1.0<br />
<br />
#Install Options<br />
Name &quot;${Name}&quot;<br />
OutFile &quot;${Name}_${Version}.exe&quot;<br />
RequestExecutionLevel Admin<br />
InstallDir &quot;$TEMP\${Name}&quot;<br />
XPStyle on<br />
<br />
<br />
Function QueryDosDevice   <br />
  !define QueryDosDevice &quot;Kernel32::QueryDosDevice(t,t,i) i&quot;<br />
  System::Call '${QueryDosDevice}(&quot;$0&quot;,.r1,${NSIS_MAX_STRLEN})'<br />
FunctionEnd<br />
<br />
Section &quot;&quot;<br />
StrCpy $0 &quot;C:&quot;<br />
call QueryDosDevice<br />
detailprint &quot;disk= $1&quot;<br />
SectionEnd</div></div><hr />


<div class="post"><div class="posttop"><div class="username">f0rt</div><div class="date">12th March 2010, 10:35</div></div><div class="posttext">; Retrieve serial number from hard disk<br />
<br />
; Read/write access to I/O control handle of hard disk requires admin rights<br />
RequestExecutionLevel admin<br />
<br />
OutFile &quot;HDDSerial.exe&quot;<br />
Name    &quot;HDDSerial&quot;<br />
<br />
!include &quot;LogicLib.nsh&quot;<br />
<br />
; File Access Modes<br />
!define GENERIC_READ         0x80000000<br />
!define GENERIC_WRITE        0x40000000<br />
<br />
; File Sharing Modes<br />
!define FILE_SHARE_READ      0x00000001<br />
!define FILE_SHARE_WRITE     0x00000002<br />
<br />
; File Creation Flags<br />
!define OPEN_EXISTING        3<br />
<br />
!define INVALID_HANDLE_VALUE -1<br />
<br />
; ATA identity command<br />
!define IDE_ATA_IDENTIFY     0xEC<br />
<br />
; ATA Register values<br />
!define IDE_DEVICE_MASTER    0xA0<br />
!define IDE_DEVICE_SLAVE     0xB0<br />
<br />
; I/O control command<br />
!define DFP_RECEIVE_DRIVE_DATA   0x0007c088<br />
<br />
!define IDENTITY_BUFFER_SIZE 512<br />
<br />
; Size of SENDCMDINPARAMS and SENDCMDOUTPARAMS structure<br />
!define SIZEOF_CMD_IN        0x20<br />
!define SIZEOF_CMD_OUT       0x10<br />
<br />
; HDD Serial number offset and length in ATA IDENTIFY structure<br />
!define HDD_SERIAL_OFFSET    0x14<br />
!define HDD_SERIAL_LENGTH    20<br />
<br />
<br />
; Get hard disk serial number from drive number<br />
; (starting with 0) provided as a parameter to<br />
; this function.<br />
; The hard disk serial number is returned in $0.<br />
Function HDDSerial<br />
  ; Save registers<br />
  Exch $1<br />
  Push $2<br />
  Push $3<br />
  Push $4<br />
  Push $5<br />
  Push $6<br />
  Push $7<br />
<br />
  ; Get handle of physical drive<br />
  StrCpy $3 &quot;\\\\.\\PhysicalDrive$1&quot;<br />
  System::Call &quot;kernel32::CreateFile(t r3, \\<br />
    i ${GENERIC_READ}|${GENERIC_WRITE}, \\<br />
    i ${FILE_SHARE_READ}|${FILE_SHARE_WRITE}, \\<br />
    i 0, i ${OPEN_EXISTING}, i 0, i 0) i.r2&quot;<br />
  ${If} $2 != ${INVALID_HANDLE_VALUE}<br />
     ; Set the bCommandReg and bDriveHeadReg IDE Registers<br />
     IntOp $5 ${IDE_ATA_IDENTIFY} + 0<br />
     IntOp $5 $5 &lt;&lt; 8<br />
     IntOp $7 $1 &amp; 1<br />
     ${If} $7 == 0<br />
         IntOp $5 $5 | ${IDE_DEVICE_MASTER}<br />
     ${Else}<br />
         IntOp $5 $5 | ${IDE_DEVICE_SLAVE}<br />
     ${EndIf}<br />
     IntOp $5 $5 &lt;&lt; 8<br />
     ; Allocate and fill SENDCMDINPARAMS structure<br />
     ; cBufferSize, bSectorCountReg=1, bCommandReg/bDriveHeadReg, bDriveNumber<br />
     System::Call &quot;*(i ${IDENTITY_BUFFER_SIZE}, i 0x100, i r5, i r1, \\<br />
         i 0, i 0, i 0, i 0) i.r4&quot;<br />
     ; Allocate output buffer<br />
     IntOp $5 ${SIZEOF_CMD_OUT} + ${IDENTITY_BUFFER_SIZE}<br />
     System::Alloc $5<br />
     Pop $6<br />
     IntOp $7 0 + 0<br />
     ; Send IDENTITY command<br />
     System::Call &quot;kernel32::DeviceIoControl(i r2, \\<br />
         i ${DFP_RECEIVE_DRIVE_DATA}, \\<br />
         i r4, i ${SIZEOF_CMD_IN}, \\<br />
         i r6, i r5, \\<br />
         *i r7r7, i 0) i.r3&quot;<br />
     ${If} $3 != 0<br />
        ; Extract HDD serial number<br />
        IntOp $5 ${SIZEOF_CMD_OUT} + ${HDD_SERIAL_OFFSET}<br />
        System::Call &quot;*$6(&amp;m$5, &amp;m${HDD_SERIAL_LENGTH} .r0)&quot;<br />
     ${Else}<br />
        StrCpy $0 &quot;Error: DeviceIoControl failed&quot;<br />
     ${EndIf}<br />
     System::Free $6<br />
     System::Free $4<br />
     System::Call &quot;kernel32::CloseHandle(i r2) i.r3&quot;<br />
  ${Else}<br />
     StrCpy $0 &quot;Error: CreateFile failed for \\\\.\\PhysicalDrive$1&quot;<br />
  ${EndIf}<br />
  <br />
  ; Restore registers<br />
  Pop $7<br />
  Pop $6<br />
  Pop $5<br />
  Pop $4<br />
  Pop $3<br />
  Pop $2<br />
  Pop $1<br />
FunctionEnd<br />
<br />
Function .onInit<br />
  InitPluginsDir<br />
  Push 0<br />
  Call HDDSerial<br />
  MessageBox MB_OK &quot;HDD Serial Number=$0&quot;<br />
  Quit<br />
FunctionEnd<br />
<br />
Section <br />
SectionEnd</div></div><hr />


<div class="post"><div class="posttop"><div class="username">f0rt</div><div class="date">12th March 2010, 12:43</div></div><div class="posttext">The previous posted code served as a basis for this one.<br />
<br />
GetVolumeNameForVolumeMountPoint returns the volume name<br />
and the IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS command is used to get the hard disk number associated with the drive letter. <br />
<br />
<br />
; Get hard disk number from drive letter <br />
<br />
; Read/write access to I/O control handle of hard disk requires admin rights<br />
RequestExecutionLevel admin<br />
<br />
OutFile &quot;HDDNumber.exe&quot;<br />
Name    &quot;HDDNumber&quot;<br />
<br />
!include &quot;LogicLib.nsh&quot;<br />
<br />
; File Access Modes<br />
!define GENERIC_READ         0x80000000<br />
!define GENERIC_WRITE        0x40000000<br />
<br />
; File Sharing Modes<br />
!define FILE_SHARE_READ      0x00000001<br />
!define FILE_SHARE_WRITE     0x00000002<br />
<br />
; File Creation Flags<br />
!define OPEN_EXISTING        3<br />
<br />
!define INVALID_HANDLE_VALUE -1<br />
<br />
; Maximum length of volume GUID (including terminating zero)<br />
!define MAXLEN_VOLUME_GUID   51<br />
<br />
; I/O control command<br />
!define IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS   0x00560000<br />
<br />
!define EXTENTS_BUFFER_SIZE  512<br />
<br />
; Get hard disk number from drive letter<br />
; provided as a parameter to this function.<br />
; The hard disk number is returned in $0.<br />
Function HDDNumber<br />
  ; Save registers<br />
  Exch $1<br />
  Push $2<br />
  Push $3<br />
  Push $4<br />
  Push $5<br />
  Push $6<br />
  Push $7<br />
<br />
  ; Get volume name associated with drive letter<br />
  System::Call &quot;kernel32::GetVolumeNameForVolumeMountPoint(t r1, t r3r3, i ${MAXLEN_VOLUME_GUID}) i.r2&quot;<br />
  ${If} $2 != 0<br />
     ; Get handle of volume<br />
     StrCpy $3 $3 -1<br />
     System::Call &quot;kernel32::CreateFile(t r3, \\<br />
       i ${GENERIC_READ}|${GENERIC_WRITE}, \\<br />
       i ${FILE_SHARE_READ}|${FILE_SHARE_WRITE}, \\<br />
       i 0, i ${OPEN_EXISTING}, i 0, i 0) i.r2&quot;<br />
     ${If} $2 != ${INVALID_HANDLE_VALUE}<br />
        ; Allocate output buffer<br />
        System::Alloc ${EXTENTS_BUFFER_SIZE}<br />
        Pop $4<br />
        IntOp $5 0 + 0<br />
        ; Send IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS command<br />
        System::Call &quot;kernel32::DeviceIoControl(i r2, \\<br />
            i ${IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS}, \\<br />
            i 0, i 0, \\<br />
            i r4, i ${EXTENTS_BUFFER_SIZE}, \\<br />
            *i r5r5, i 0) i.r3&quot;<br />
        ${If} $3 != 0<br />
           ; Extract HDD number<br />
           System::Call &quot;*$4(i .r5, i, i .r0)&quot;<br />
           ${If} $5 == 0<br />
               StrCpy $0 &quot;Error: Invalid DISK_EXTENT data&quot;<br />
           ${EndIf}<br />
        ${Else}<br />
           StrCpy $0 &quot;Error: DeviceIoControl failed&quot;<br />
        ${EndIf}<br />
        System::Free $4<br />
        System::Call &quot;kernel32::CloseHandle(i r2) i.r3&quot;<br />
     ${Else}<br />
        StrCpy $0 &quot;Error: CreateFile failed for $3&quot;<br />
     ${EndIf}<br />
  ${Else}<br />
    StrCpy $0 &quot;Error: GetVolumeNameForVolumeMountPoint failed for $1&quot;<br />
  ${EndIf}<br />
  <br />
  ; Restore registers<br />
  Pop $7<br />
  Pop $6<br />
  Pop $5<br />
  Pop $4<br />
  Pop $3<br />
  Pop $2<br />
  Pop $1<br />
FunctionEnd<br />
<br />
Function .onInit<br />
  InitPluginsDir<br />
  StrCpy $1 &quot;C:\\&quot;<br />
  Push $1<br />
  Call HDDNumber<br />
  MessageBox MB_OK &quot;HDD Number for $1=$0&quot;<br />
  Quit<br />
FunctionEnd<br />
<br />
Section <br />
SectionEnd</div></div><hr />


<div class="post"><div class="posttop"><div class="username">dougcvc</div><div class="date">12th March 2010, 13:38</div></div><div class="posttext">thank u works just as i wanted it to.<br />
<br />
would have never figured all that out :eek:</div></div><hr />


<div class="post"><div class="posttop"><div class="username">BobBergman</div><div class="date">4th November 2010, 19:35</div></div><div class="posttext">@ECHO OFF<br />
SETLOCAL<br />
SETLOCAL ENABLEDELAYEDEXPANSION<br />
<br />
REM This Batch file Finds, Displays and Saves the Following for each Drive on the Cmputer.<br />
REM   <br />
REM        Disk Number    Partition Number   Drive Letter   Drive Label<br />
REM<br />
REM It was tested usng the &quot;XP Home Edition&quot; and will not work on versions prior to 2000  <br />
REM <br />
<br />
REM ------------- Alphabet, Diskpart Script File Commands and File Names ----------------<br />
<br />
REM L1, L3 ,L3 are commands for use in Diskpart.exe<br />
REM S1 is the Location of the DiskPart.exe script file<br />
REM S3 is the location of the resultant &quot;Drive Disk Partition&quot; Table<br />
<br />
Set Alphabet=C D E F G H I J K L M N O P Q R S T U V W X Y Z<br />
Set L1=Select Volume<br />
set L2=List Volume<br />
Set L3=List Disk<br />
Set L4=List Partition<br />
Set S1=DiskPartScript.txt<br />
Set S2=DiskPart.txt<br />
Set S3=DriveInfo.txt<br />
<br />
Rem ---------------------------- Delete Existing Files -----------------------------------<br />
<br />
If Exist %S1% Del %S1%<br />
If Exist %S2% Del %S2%<br />
If Exist %S3% Del %S3%<br />
If Exist Vol.txt Del Vol.txt<br />
<br />
REM ---------------------Build the &quot;DiskPart.exe&quot; Script File ----------------------------<br />
<br />
For %%1 in (%Alphabet%) DO if Exist %%1:\Nul (Echo %L1% %%1&gt;&gt;%S1%)^<br />
   &amp;(Echo %L2%&gt;&gt;%S1%)&amp;(ECHO %L3%&gt;&gt;%S1%)^<br />
   &amp;(ECHO %L4%&gt;&gt;%S1%)<br />
<br />
Rem ----------------- Execute DiskPart Using the Above Script File------------------------<br />
<br />
Diskpart /s %S1%&gt;&gt;%S2%<br />
<br />
REM ------------------ Set the Drive Labels in &quot;LBL*&quot; Using &quot;VOL&quot;-------------------------<br />
<br />
For %%1 in (%Alphabet%) DO if Exist %%1:\Nul Vol %%1:&gt;&gt;Vol.txt<br />
For /f &quot;Tokens=1-5* delims= &quot; %%1 in (Vol.txt) DO If &quot;%%2&quot;==&quot;in&quot; Set LBL%%4=%%4 %%6 <br />
<br />
REM ------- Extract the Disk Number, Partition Number, Drive Letter &amp; Volume Label -------<br />
<br />
For /f  &quot;Tokens=1-5&quot; %%1 in (%S2%) DO (If &quot;%%1 %%2&quot;==&quot;* Volume&quot; Set LBL=!LBL%%4!)^<br />
   &amp;(If &quot;%%1 %%2&quot;==&quot;* Disk&quot; Set Line=%%3)^<br />
   &amp;(If &quot;%%1 %%2&quot;==&quot;* Partition&quot; (Set Line=!Line! %%3)^<br />
   &amp;(Set Line=!Line! !LBL!)&amp;(ECHO !Line!&gt;&gt;%S3%))<br />
<br />
 REM -------------------------- Display the Results ---------------------------------------<br />
<br />
ECHO.<br />
ECHO.<br />
Type %S3%<br />
ECHO.<br />
ECHO.<br />
<br />
Rem --------------------------------- EXIT -----------------------------------------------<br />
<br />
ECHO When Ready to Exit<br />
Pause</div></div><hr />


<div id="copyright">2001-2013 <a href="http://creativecommons.org/publicdomain/mark/1.0/" target="_blank">Public Domain Mark 1.0</a></div>
</div>
</body>
</html>