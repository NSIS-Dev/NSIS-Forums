<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="keywords" content=" Another string tokenizer, media player, mp3 player, music player, ipod sync, multimedia player, player, winamp, audio player" />
	<meta name="description" content="[Archive]  Another string tokenizer NSIS Discussion" />
	
	<title> Another string tokenizer [Archive]  - Winamp Forums</title>
	<link rel="stylesheet" type="text/css" href="archive.css" />
</head>
<body>
<div class="pagebody">
<div id="navbar">Winamp Forums &gt; Developer Center &gt; <a href="f-65.html">NSIS Discussion</a> &gt;  Another string tokenizer</div>
<hr />
<div class="pda"><a href="t-296562.html?login=1" rel="nofollow">Log in</a></div>
<p class="largefont">Try the Internet Archive: <a href="http://web.archive.org/web/*/forums.winamp.com/showthread.php?t=296562">Another string tokenizer</a></p>
<hr />

<div class="post"><div class="posttop"><div class="username">badger101101</div><div class="date">27th August 2008, 17:29</div></div><div class="posttext">I recently did some work on an installer and came across the need to tokenize a list of strings.  I first attempted to use the macro as defined here:  http://nsis.sourceforge.net/Split_strings  which tokenizes strings of the form &quot;string1&quot; &quot;string2&quot; ... &quot;stringN&quot;.  One problem with the macro is that it doesn't allow your strings to contain spaces.  So I wrote a simple function to parse a string based on a delimiter instead.  You may want to convert it into a macro, or even optimize it a bit, but I thought it might be useful for someone.  <br />
<br />
<br />
Function gettoken<br />
  Pop $0 ;list of strings<br />
  Pop $1 ;desired token number<br />
  StrCpy 	$R0 0  ;base index<br />
  StrCpy  	$R1 -1 ;string index<br />
  StrCpy        $R3 1  ;iteration<br />
  StrLen        $R5 $0<br />
  <br />
token_nextchar:<br />
  IntOp  	$R1 $R1 + 1   <br />
  IntCmp        $R1 $R5 token_empty 0 0<br />
  StrCpy	$R2 $0 1 $R1<br />
  StrCmp 	$R2 '|' 0 token_nextchar<br />
  IntCmp        $R3 $1 token_return token_nexttoken 0<br />
token_nexttoken:<br />
  IntOp         $R0 $R1 + 1<br />
  IntOp         $R3 $R3 + 1<br />
  Goto          token_nextchar<br />
token_return:<br />
  IntOp         $R4 $R1 - $R0<br />
  StrCpy        $R2 $0 $R4 $R0<br />
  Goto          token_done<br />
token_empty:<br />
  StrCpy        $R2 &quot;_empty_&quot;<br />
token_done:<br />
  Push          $R2<br />
FunctionEnd<br />
<br />
<br />
Currently the delimiter is hard-coded to '|' but you could easily make that a parameter.  Before calling the function, you need to push both the token number you want returned and the list of strings onto the stack.  One caveat to note is that the the list of string needs to have a delimiter at the very end.  So an example of a working list of strings would be:<br />
<br />
&quot;The United States of America|Japan|Korea|China|&quot;<br />
<br />
You can iterate from 1 to N calling the function at each index to tokenize the entire list.  The return value is pushed onto the stack.  Your iteration can terminate if the return value was &quot;_empty_&quot;.</div></div><hr />


<div id="copyright">2001-2013 <a href="http://creativecommons.org/publicdomain/mark/1.0/" target="_blank">Public Domain Mark 1.0</a></div>
</div>
</body>
</html>