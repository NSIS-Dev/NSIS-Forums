<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="keywords" content=" Problem using ${RunningX64}, media player, mp3 player, music player, ipod sync, multimedia player, player, winamp, audio player" />
	<meta name="description" content="[Archive]  Problem using ${RunningX64} NSIS Discussion" />
	
	<title> Problem using ${RunningX64} [Archive]  - Winamp Forums</title>
	<link rel="stylesheet" type="text/css" href="archive.css" />
</head>
<body>
<div class="pagebody">
<div id="navbar">Winamp Forums &gt; Developer Center &gt; <a href="f-65.html">NSIS Discussion</a> &gt;  Problem using ${RunningX64}</div>
<hr />
<div class="pda"><a href="t-333931.html?login=1" rel="nofollow">Log in</a></div>
<p class="largefont">Try the Internet Archive: <a href="http://web.archive.org/web/*/forums.winamp.com/showthread.php?t=333931">Problem using ${RunningX64}</a></p>
<hr />

<div class="post"><div class="posttop"><div class="username">jai123</div><div class="date">22nd August 2011, 20:05</div></div><div class="posttext">I am using the code below in several parts of my script.<br />
<br />
${If} ${RunningX64}<br />
; 64bit bits go here<br />
${Else}<br />
; 32bit bits go here<br />
${EndIf} <br />
<br />
In one function it runs perfectly fine, but the other calls will not work unless they are used after the initial call that executed correctly.<br />
<br />
I have not been able to find any logical reason for this behavior. I have included both the LogicLib.nsh and x64.nsh heather files, but it goes through the 64 bit section. <br />
<br />
What could it be? There does not seem to be any macros to initialize prior their use. Any ideas?</div></div><hr />


<div class="post"><div class="posttop"><div class="username">LoRd_MuldeR</div><div class="date">22nd August 2011, 21:27</div></div><div class="posttext">Can you post a complete (minimal) example to reproduce the issue?</div></div><hr />


<div class="post"><div class="posttop"><div class="username">jai123</div><div class="date">22nd August 2011, 21:59</div></div><div class="posttext">In the main.nsi script you can see the explanation of the problems.<br />
<br />
If Call installDrivers is executed before Call installCNCInterface, RunningX64 will work fine for both. If Call installDrivers is executed after  Call installCNCInterface, the macro will not work for installCNCInterface, but it will work for installDrivers.<br />
<br />
Call un.uninstallDrivers will never work<br />
<br />
The only way I have tried this out is in a 32 bit system, in which chooses the 64 bit option.<br />
<br />
# main.nsi file<br />
<br />
!include &quot;LogicLib.nsh&quot;             ; Library for logical statements <br />
!include &quot;x64.nsh&quot;                  ; Macros for x64 machines<br />
<br />
....<br />
....<br />
....<br />
<br />
# Techno CNC Interface <br />
SectionGroup /e &quot;!CNC Software&quot; SecCNC_Software<br />
    Section &quot;Interface&quot; SecCNC_Interface<br />
<br />
        SetRebootFlag true<br />
        ;Call installDrivers      WHEN THIS LINE IS ADDED, installCNCInterface uses properly RunningX64 macro <br />
<br />
        # creates a temp directory in which we will work.<br />
        setOutPath $INSTDIR<br />
        Call installVB6Runtimes<br />
        Call installCNCInterface   IT WILL RUN PROPERLY THE MACRO DEPENDING ON calling installDrivers before calling this function<br />
<br />
	    WriteUninstaller &quot;$InstDir\uninstaller.exe&quot;<br />
<br />
    SectionEnd<br />
SectionGroupEnd<br />
<br />
....<br />
....<br />
....<br />
<br />
# Uninstalle Components<br />
<br />
Section &quot;uninstall&quot;<br />
 <br />
   Call un.uninstallDrivers  NEVER CALL PROPERLY THE runningX64 macro<br />
<br />
    # Delete uninstaller<br />
    delete &quot;$InstDir\uninstall.exe&quot;<br />
 <br />
SectionEnd<br />
<br />
<br />
######################################################<br />
# Secondary.nsh file<br />
<br />
!macro  extractDriverFiles<br />
<br />
    # extracts respective drivers content<br />
    ${If} ${RunningX64}<br />
        file Drivers\x64\*.*<br />
    ${Else}<br />
        file Drivers\x86\*.*<br />
    ${EndIf}<br />
<br />
!macroend<br />
<br />
....<br />
....<br />
....<br />
<br />
Function disableDevices<br />
<br />
    # Assures that the kernel plug in and pci device are not open or service<br />
    execWait &quot;wdreg_gui -name pciservo -silent uninstall&quot;   ;-silent flag will omit error messages when the drivers have never been installed before.<br />
    ${If} ${RunningX64}<br />
        execWait 'wdreg_gui -inf &quot;$OUTDIR\TechnoPCIController_device.inf&quot; -silent disable'<br />
    ${Else}<br />
        execWait 'wdreg_gui -inf &quot;$OUTDIR\pciservo.inf&quot; -silent disable'<br />
    ${EndIf}<br />
<br />
FunctionEnd<br />
<br />
<br />
Function setupDrivers<br />
<br />
    !insertmacro extractDriverFiles<br />
    Call disableDevices     ; to install the drivers cleanly, no devices have to be enabled<br />
    !insertmacro cleanFileSystem <br />
<br />
FunctionEnd<br />
<br />
Function executeDriverInstallation<br />
    ${If} ${RunningX64}<br />
       .....<br />
    ${Else}<br />
        .....<br />
    ${EndIf}<br />
FunctionEnd<br />
<br />
Function installDrivers<br />
<br />
    # save the original output dir<br />
    Push $R0<br />
    StrCpy $R0 $OUTDIR <br />
    setOutPath $TEMP\Drivers<br />
<br />
    Call setupDrivers<br />
    Call executeDriverInstallation<br />
    <br />
    # Remove temporal files<br />
    setOutPath $TEMP     ; output directory has to be different than deleted below. Otherwise, NSIS will not delete them.<br />
    RMDir /r &quot;$TEMP\Drivers&quot;<br />
FunctionEnd<br />
<br />
# ---------------------------------------------<br />
# Uninstallation <br />
<br />
Function un.executeDriverUninstallation<br />
<br />
    # Assures that there are no services running or connected devices.<br />
    ${If} ${RunningX64}<br />
        ..............<br />
    ${Else}<br />
        .............<br />
    ${EndIf}<br />
FunctionEnd<br />
<br />
Function un.uninstallDrivers<br />
<br />
    # save the original output dir<br />
    Push $R0<br />
    StrCpy $R0 $OUTDIR <br />
    setOutPath $TEMP\Drivers<br />
<br />
    !insertmacro extractDriverFiles<br />
    Call un.executeDriverUninstallation<br />
    !insertmacro cleanFileSystem<br />
<br />
    # Remove temporal files<br />
    setOutPath $TEMP     ; output directory has to be different than deleted below. Otherwise, NSIS will not delete them.<br />
    RMDir /r &quot;$TEMP\Drivers&quot;<br />
<br />
    # recover output dir<br />
    setOutPath $R0<br />
    Pop $R0<br />
<br />
FunctionEnd<br />
<br />
####################################<br />
# AnotherSupport.nsh<br />
<br />
!include &quot;LogicLib.nsh&quot;             ; Library for logical statements <br />
!include &quot;x64.nsh&quot;                  ; Macros for x64 machines<br />
<br />
Var ALREADY_INSTALLED<br />
Var Version<br />
<br />
Function installCNCInterface<br />
 <br />
    ............<br />
   <br />
    # user mode pnp file<br />
    ${If} ${RunningX64}<br />
        ..........<br />
    ${Else}<br />
        ..........<br />
    ${EndIf}<br />
<br />
    .......<br />
FunctionEnd</div></div><hr />


<div class="post"><div class="posttop"><div class="username">MSG</div><div class="date">22nd August 2011, 22:11</div></div><div class="posttext">Make sure you !inlude x64.nsh at the very top of your nsi script.<br />
<br />
Edit: Nevermind. :)</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Anders</div><div class="date">22nd August 2011, 22:39</div></div><div class="posttext">I can't really get your example to fail on a 32 bit XP system.<br />
<br />
Just for fun, insert this before the ${If} that fails:<br />
<br />
System::Call kernel32::GetCurrentProcess()i.s<br />
System::Call 'kernel32::IsWow64Process(is,*i.r1)i.r0 ?e'<br />
pop $2<br />
MessageBox mb_ok &quot;IsWow64=$1,ret=$0,gle=$2&quot;</div></div><hr />


<div class="post"><div class="posttop"><div class="username">jai123</div><div class="date">23rd August 2011, 14:24</div></div><div class="posttext">Anders:<br />
<br />
The code that you suggested always returns<br />
<br />
IsWow64=0,ret=1,gle=80<br />
<br />
I am not sure what ret=1 and gle=80 means, but it seems that it is confirming that is 32 to bit all the time. Might be something wrong with the RunningX64 macro? maybe I am using an outdated one?<br />
<br />
Here is the code<br />
<br />
!macro _RunningX64 _a _b _t _f<br />
  !insertmacro _LOGICLIB_TEMP<br />
  System::Call kernel32::GetCurrentProcess()i.s<br />
  System::Call kernel32::IsWow64Process(is,*i.s)<br />
  Pop $_LOGICLIB_TEMP<br />
  !insertmacro _!= $_LOGICLIB_TEMP 0 `${_t}` `${_f}`<br />
!macroend<br />
<br />
!define RunningX64 `&quot;&quot; RunningX64 &quot;&quot;`<br />
<br />
Thanks</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Anders</div><div class="date">23rd August 2011, 19:50</div></div><div class="posttext">ret=1 means the function worked correctly (Ignore GLE on success).<br />
<br />
The macro is probably not the problem. Is it possible that you have a goto or hardcoded jump (+3 etc) in your code?</div></div><hr />


<div class="post"><div class="posttop"><div class="username">jai123</div><div class="date">23rd August 2011, 20:14</div></div><div class="posttext">Nop, I do not use Goto in my code.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">jai123</div><div class="date">24th August 2011, 19:05</div></div><div class="posttext">The problem was a macro that I was using for File redirection. The code is below.<br />
<br />
I do not understand why the redefinition of RunningX64 was sometimes causing the symptoms that I mentioned above, but I just got rid of it.<br />
<br />
Thanks<br />
<br />
!include x64.nsh<br />
<br />
Var SYSWOW64DIR<br />
!macro _SystemDirsInit<br />
  ${DisableX64FSRedirection}<br />
  ${If} ${RunningX64}<br />
    StrCpy $SYSWOW64DIR $WINDIR\SysWOW64<br />
  ${Else}<br />
    StrCpy $SYSWOW64DIR $SYSDIR<br />
  ${EndIf}<br />
<br />
  !ifdef RunningX64<br />
    !undef RunningX64<br />
  !endif<br />
  !define RunningX64 `$SYSWOW64DIR != $SYSDIR`<br />
<br />
!macroend<br />
!define SystemDirsInit `!insertmacro _SystemDirsInit`<br />
<br />
!endif</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Anders</div><div class="date">24th August 2011, 20:34</div></div><div class="posttext">You should only disable FSRedirection for a short time to install files, then enable it again since it will prevent proper dll loading etc...</div></div><hr />


<div id="copyright">2001-2013 <a href="http://creativecommons.org/publicdomain/mark/1.0/" target="_blank">Public Domain Mark 1.0</a></div>
</div>
</body>
</html>