<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="keywords" content=" How to declare new variables at runtime, media player, mp3 player, music player, ipod sync, multimedia player, player, winamp, audio player" />
	<meta name="description" content="[Archive]  How to declare new variables at runtime NSIS Discussion" />
	
	<title> How to declare new variables at runtime [Archive]  - Winamp Forums</title>
	<link rel="stylesheet" type="text/css" href="archive.css" />
</head>
<body>
<div class="pagebody">
<div id="navbar">Winamp Forums &gt; Developer Center &gt; <a href="f-65.html">NSIS Discussion</a> &gt;  How to declare new variables at runtime</div>
<hr />
<div class="pda"><a href="t-243814.html?login=1" rel="nofollow">Log in</a></div>
<p class="largefont">Try the Internet Archive: <a href="http://web.archive.org/web/*/forums.winamp.com/showthread.php?t=243814">How to declare new variables at runtime</a></p>
<hr />

<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">18th April 2006, 11:40</div></div><div class="posttext">I am calling a system function which returns an array of n data entries in an array + the total number of entries in the array. The total number of entries may vary between computers so I can't define n number of variables at compilation time. I am looking for a method to declare n variables within a function or section, something like this:<br />
...<br />
Function blah<br />
Pop $R0 ; a pointer to the buffer containing the array<br />
Pop $R1 ; the total number of entries in $R1<br />
StrCpy $Counter 1<br />
loop1:<br />
${If} $Counter &lt;&gt; $R1<br />
Var /GLOBAL &quot;Entry_$Counter&quot;<br />
StrCpy $Counter $Counter +1<br />
Goto loop1<br />
${Else}<br />
Goto loop1end<br />
${EndIf}<br />
loop1end:<br />
<br />
StrCpy $Counter 1<br />
StrCpy $ArrayElements &quot;w .$Entry_$Counter&quot;<br />
loop2:<br />
${If} $Counter &lt;&gt; $R1<br />
StrCpy $ArrayElements &quot;$ArrayElements, w .$Entry_$Counter&quot;<br />
StrCpy $Counter $Counter +1<br />
Goto loop2<br />
${Else}<br />
Goto loop2end<br />
${EndIf}<br />
loop2end:<br />
<br />
System::Call '*$R0(&quot;$ArrayElements&quot;)' ; get the elements of the array to $Entry_$Counter variables<br />
...<br />
FunctionEnd<br />
The above is not working ofcourse, so I was hoping that somebod ywould have a better idea<br />
Thanks<br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Takhir</div><div class="date">18th April 2006, 11:48</div></div><div class="posttext">May be this link will be usefull http://nsis.sourceforge.net/Array_plug-in ;)</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">18th April 2006, 12:01</div></div><div class="posttext">Thanks Takhir,<br />
I tried before with AfrowUK's plugin but could not get it to work. My problem, as I stated in my post, is that I do not know the length of the array in advance...<br />
Suppose I start feeding data to an array, until my counter reaches $R1 (total number of entries). Then I would have to pop the data out eventually to variables in order to use them in my system call. Still no good because I would have to define those variables, but I do not know their number in advance ...<br />
<br />
It may be obvious how to deal with this but I really can't see the solution <br />
<br />
:igor: <br />
<br />
CF<br />
<br />
[Edit]<br />
I guess if I didn't need all the entries out, I could just pick one at a time, process it and then pick the next until I run out of entries ... Good enough for me :)<br />
However what happens if I want them all?</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">18th April 2006, 12:30</div></div><div class="posttext">Use the stack:<br />
<br />
Push,<br />
Pop<br />
etc<br />
<br />
-Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">18th April 2006, 14:19</div></div><div class="posttext">Fair enough.<br />
The build in variables (registers) in NSIS are $0-$9 and $R0-$R9.<br />
Is there a way to have more than 20 variables at the same time, without declaring them when compiling?<br />
CF<br />
<br />
[Edit]<br />
Maybe I should explain the problem a bit more...<br />
I have an array of n-elements stored at a memory buffer ($R0 for my example). The only way I can pop the elements out is by calling:<br />
System::Call '*$R0(w .$0, w .$1, ...,w .$n)'The total number of elements (n) is unknown when I am compiling my program so I cannot define n variables.<br />
<br />
How is it possible, using the Array plugin, to pop all the elements out of the memory into an Array of variables (or just into an array)?<br />
<br />
For example, if I callSystem::Call '*$R0(w .$0)'I will pop only the first element from the buffer, if I callSystem::Call '*$R0(w .$0, w $1)'I will pop the first and the second etc.<br />
If I have more then 20 elements, I will run out of registers ...<br />
<br />
In other words I cannot pop out one at a time from the buffer, I have to pop them out all at once using n variables to accept them ...<br />
<br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">18th April 2006, 14:59</div></div><div class="posttext">Duh, the answer was simple ...<br />
Pop out 20 fisrt then repeat with the remaining setting the first 20 to null :)<br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">18th April 2006, 15:57</div></div><div class="posttext">This is frustrating ...<br />
If I try to pop 20 elements at a time, I still do not know how to deal with the memory buffer as the system::call command is a function of the number of elements. For example if I pop 5 at a time (so that I don't have to write 20 here!); $R0 is the buffer of the momory structure<br />
; $R1 is the number of elements in $R0<br />
NSISArray::New /NOUNLOAD SomeArray<br />
System::Call '*$R0(w $5, w $6, w $7, w $8, w $9)' ; first call<br />
NSISArray::WriteList /NOUNLOAD SomeArray &quot;$5&quot; &quot;$6&quot; &quot;$7&quot; &quot;$8&quot; &quot;$9&quot; /END<br />
NSISArray::SizeOf /NOUNLOAD SomeArray<br />
Pop $R9<br />
StrCmp $R9 $R1 end step2<br />
<br />
step2:<br />
System::Call '*$R0(v,v,v,v,v,w $5, w $6, w $7, w $8, w $9)'<br />
NSISArray::WriteList /NOUNLOAD SomeArray &quot;$5&quot; &quot;$6&quot; &quot;$7&quot; &quot;$8&quot; &quot;$9&quot; /END<br />
NSISArray::SizeOf /NOUNLOAD SomeArray<br />
Pop $R9<br />
StrCmp $R9 $R1 end step3<br />
<br />
step3:<br />
System::Call '*$R0(v,v,v,v,v,v,v,v,v,v,w $5, w $6, w $7, w $8, w $9)'<br />
NSISArray::WriteList /NOUNLOAD SomeArray &quot;$5&quot; &quot;$6&quot; &quot;$7&quot; &quot;$8&quot; &quot;$9&quot; /END<br />
NSISArray::SizeOf /NOUNLOAD SomeArray<br />
Pop $R9<br />
StrCmp $R9 $R1 end step4<br />
...<br />
<br />
end:<br />
...(plus some code in between to empty the variables before calling calling the structure to ensure that I am not getting the same elements when I reach the end of the structure)<br />
Any ideas on how to improve this?<br />
<br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">deguix</div><div class="date">18th April 2006, 17:19</div></div><div class="posttext">In the line &quot;System::Call '*$R0(...'&quot; -&gt; the variable $R0 means the memory location of the data in that case. Thus you could use IntOp to go to the next array item by adding the string length (using IntOp). You would also need to know the array size to loop, but I think you already have that.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">18th April 2006, 18:00</div></div><div class="posttext">Thanks deguix, but it it din't work :(<br />
; $R0 is the buffer of the momory structure<br />
; $R1 is the number of elements in $R0<br />
System::Call '*$R0(w .r1)' ; get first entry out<br />
StrLen $2 '$1'<br />
IntOp $2 $2 + 1<br />
IntOp $R0 $R0 + $2<br />
System::Call '*$R0(w.r1)' ; get second entry outIt breaks after the first entry is out.<br />
<br />
I can get all the entries out like this:System::Call '*$R0(w.r1,w.r2,w.r3,....w.rn)but not one at the time ...<br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">18th April 2006, 18:04</div></div><div class="posttext">Got it!<br />
; $R0 is the buffer of the momory structure<br />
; $R1 is the number of elements in $R0<br />
System::Call '*$R0(w .r1)' ; get first entry out<br />
StrLen $2 '$1'<br />
IntOp $2 $2 + 2<br />
IntOp $R0 $R0 + $2<br />
System::Call '*$R0(w.r1)' ; get second entry out<br />
If I add two nulls on any entry then call the function again I get the next entry :)<br />
<br />
Thanks a lot deguix, you made my day :)<br />
<br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">18th April 2006, 18:49</div></div><div class="posttext">I'd like to add dynamic arrays in my plugin, just need to find time.<br />
<br />
-Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">18th April 2006, 19:16</div></div><div class="posttext">Looking forward to that<br />
:D <br />
CF</div></div><hr />


<div class="post"><div class="posttop"><div class="username">deguix</div><div class="date">19th April 2006, 22:35</div></div><div class="posttext">You are just adding 1 null actually, because you are going to the first character of the next string, thus you needed to  advance 2 characters. StrLen doesn't count the last null character.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">CancerFace</div><div class="date">20th April 2006, 09:18</div></div><div class="posttext">Thanks for the clarification deguix, it makes sense now.<br />
I was trying to enumerate the local groups using NetLocalGroupEnum. Although the previous example seemed to work, it is still wrong in my case.<br />
Here is the one that worked:!define LOCAL_GROUP_INFO_0 0<br />
System::Int64Op 1 * 0x000000<br />
Pop $R4<br />
System::Call 'netapi32.dll::NetLocalGroupEnum(n,i${LOCAL_GROUP_INFO_0},*i.R1,i${NSIS_MAX_STRLEN},*i.R2,*i.R3,*i.R4)'<br />
NSISArray::New /NOUNLOAD LocalGroups<br />
StrCpy $Counter 0<br />
FeedArray:<br />
${If} $Counter &lt; $R3<br />
System::Call '*$R1(w.R5)'<br />
NSISArray::Write /NOUNLOAD LocalGroups $Counter &quot;$R5&quot;<br />
IntOp $R1 $R1 + 4<br />
IntOp $Counter $Counter + 1<br />
Goto FeedArray<br />
${EndIf}<br />
NSISArray::SizeOf /NOUNLOAD LocalGroups<br />
Pop $0<br />
System::Call 'netapi32.dll::NetApiBufferFree($R1)'The above code will get all the local group names to the LocalGroups array.<br />
;)<br />
<br />
CF</div></div><hr />


<div id="copyright">2001-2013 <a href="http://creativecommons.org/publicdomain/mark/1.0/" target="_blank">Public Domain Mark 1.0</a></div>
</div>
</body>
</html>