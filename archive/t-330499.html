<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="keywords" content=" How to use switch /sms?, media player, mp3 player, music player, ipod sync, multimedia player, player, winamp, audio player" />
	<meta name="description" content="[Archive]  How to use switch /sms? NSIS Discussion" />
	
	<title> How to use switch /sms? [Archive]  - Winamp Forums</title>
	<link rel="stylesheet" type="text/css" href="archive.css" />
</head>
<body>
<div class="pagebody">
<div id="navbar">Winamp Forums &gt; Developer Center &gt; <a href="f-65.html">NSIS Discussion</a> &gt;  How to use switch /sms?</div>
<hr />
<div class="pda"><a href="t-330499.html?login=1" rel="nofollow">Log in</a></div>
<p class="largefont">Try the Internet Archive: <a href="http://web.archive.org/web/*/forums.winamp.com/showthread.php?t=330499">How to use switch /sms?</a></p>
<hr />

<div class="post"><div class="posttop"><div class="username">JohnChen</div><div class="date">10th May 2011, 22:41</div></div><div class="posttext">I call ExecWait with the switch /sms to make the uninstaller wait until it is done. But it doesn't wait. Here is how I use it.<br />
<br />
ExecWait '&quot;$R0&quot; /sms'<br />
<br />
Here  $R0 is an executable. Thanks.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Anders</div><div class="date">10th May 2011, 22:57</div></div><div class="posttext">/sms is not a NSIS switch...</div></div><hr />


<div class="post"><div class="posttop"><div class="username">JohnChen</div><div class="date">10th May 2011, 23:01</div></div><div class="posttext">/sms is not a NSIS switch...<br />
I see. So how can I do the similar thing like /sms in NSIS? Thanks.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">T.Slappy</div><div class="date">11th May 2011, 07:28</div></div><div class="posttext">What does /sms do?</div></div><hr />


<div class="post"><div class="posttop"><div class="username">JohnChen</div><div class="date">11th May 2011, 16:53</div></div><div class="posttext">What does /sms do?<br />
/sms makes ExecWait wait until the current uninstallation is done.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">JohnChen</div><div class="date">11th May 2011, 16:54</div></div><div class="posttext">I call ExecWait with the switch /sms to make the uninstaller wait until it is done. But it doesn't wait. Here is how I use it.<br />
<br />
ExecWait '&quot;$R0&quot; /sms'<br />
<br />
Here  $R0 is an executable. Thanks.<br />
FYI,  _?=$INSTDIR' works for me. It looks like  _?=$INSTDIR' works with NSIS ExecWait. Thanks.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">JohnChen</div><div class="date">11th May 2011, 17:15</div></div><div class="posttext">FYI,  _?=$INSTDIR' works for me. It looks like  _?=$INSTDIR' works with NSIS ExecWait. Thanks.<br />
Does any one know why _?=$INSTDIR ? I found it on the web but I don't really know what it is. Thanks.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">11th May 2011, 17:22</div></div><div class="posttext">It has nothing to do with ExecWait really. All it does is stops the uninstaller copying itself to %TEMP% and relaunching from there (i.e. spawning a new process and so the old process closes; ExecWait returns).<br />
<br />
http://nsis.sourceforge.net/Docs/Chapter3.html#3.2.2<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">RaggieSoft</div><div class="date">12th May 2011, 03:51</div></div><div class="posttext">/sms is an old switch from InstallShield 3 and InstallShield 5 installers (popular around the Windows 95/98 era, InstallShield 6 did away with /sms - it came out around the time of Windows 2000)<br />
<br />
What it did:<br />
<br />
Back then, you would see &quot;Setup is preparing the InstallShield wizard...&quot; along with a progress bar.  That EXE would immediately exit upon launch of the main installer (I'm talking installer, not uninstaller).  SMS is Microsoft's Systems Management Server (I don't think they make it any more) and calling an InstallShield EXE with /sms was how you got SMS (or any other program, like a parent installation calling a 3rd party redist installer) to WAIT for installation to finish.  My guess is that InstallShield assumed most people needing to keep a parent waiting were using Microsoft's SMS (thus why the switch is &quot;/sms&quot;)<br />
<br />
An alternative would be the old WinZip Self-Extractor being told to wait for a program called _ISDEL to run (this would clean up InstallShield EXE temporary files after installation is completed).<br />
<br />
Granted, these were done in enterprises long before Microsoft came out with Windows Installer, and this is the very old way to do it.<br />
<br />
<br />
Hope this answers any questions on what /sms is.  I haven't seen it discussed in years</div></div><hr />


<div class="post"><div class="posttop"><div class="username">RaggieSoft</div><div class="date">12th May 2011, 03:58</div></div><div class="posttext">Assuming you're trying to uninstall a program from a parent uninstaller (and you want the parent uninstaller to wait for the child), here's how to duplicate:<br />
<br />
In this example, the child program uninstaller is called uninstall.exe and the child program is installed to C:\Program Files (x86)\Program 2\<br />
<br />
1. Your parent uninstaller needs to COPY the child's uninstaller EXE to another folder such $TEMP.  This is because Windows doesn't allow an EXE to delete itself<br />
2. the PARENT uninstaller would then call ExecWait $TEMP\uninstall.exe _?=C:\Program Files (x86)\Program 2\.  (this path shouldn't be hard coded - your uninstaller should use a registry key/value (for example, as it's fastest) to grab the path of the child)</div></div><hr />


<div class="post"><div class="posttop"><div class="username">JohnChen</div><div class="date">12th May 2011, 20:03</div></div><div class="posttext">Assuming you're trying to uninstall a program from a parent uninstaller (and you want the parent uninstaller to wait for the child), here's how to duplicate:<br />
<br />
In this example, the child program uninstaller is called uninstall.exe and the child program is installed to C:\Program Files (x86)\Program 2\<br />
<br />
1. Your parent uninstaller needs to COPY the child's uninstaller EXE to another folder such $TEMP.  This is because Windows doesn't allow an EXE to delete itself<br />
2. the PARENT uninstaller would then call ExecWait $TEMP\uninstall.exe _?=C:\Program Files (x86)\Program 2\.  (this path shouldn't be hard coded - your uninstaller should use a registry key/value (for example, as it's fastest) to grab the path of the child)<br />
If the uninstaller has one parameter, so I thought I should call ExecWait like this,'<br />
ExecWait '&quot;$0&quot; &quot;$1&quot; &quot;_?=$INSTDIR&quot;'	<br />
Here $0 is uninstaller and $1 is its parameter. But I got an error like &quot;Parsing Failed: Unable to open file _?&quot;. What did I wrong? Thanks.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">12th May 2011, 21:02</div></div><div class="posttext">Read the manual page that I linked to.<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">JohnChen</div><div class="date">12th May 2011, 21:21</div></div><div class="posttext">Read the manual page that I linked to.<br />
<br />
Stu<br />
Actually I did. The manual page you linked to contains some examples demonstrating how to use ExecWait with _?=. But in those examples, the uninstaller doesn't take any parameter. My specific problem is related to that when the uninstaller takes one parameter, ExecWait failed with error message like &quot;Parsing Failed: Unable to open file _?&quot;<br />
Here is how I did,<br />
ExecWait '&quot;$0&quot; &quot;$1&quot; &quot;_?=$INSTDIR&quot;' <br />
$0 is the uninstaller and $1 is its parameter. Is there anything wrong in this statement? Thanks.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">12th May 2011, 21:24</div></div><div class="posttext">You missed this:It must be the last parameter used in the command line and must not contain any quotes, even if the path contains spaces.Edit: I.e. ExecWait '&quot;$0&quot; &quot;$1&quot; _?=$INSTDIR'<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">JohnChen</div><div class="date">12th May 2011, 22:25</div></div><div class="posttext">You missed this:Edit: I.e. ExecWait '&quot;$0&quot; &quot;$1&quot; _?=$INSTDIR'<br />
<br />
Stu<br />
Unfortunately this one doesn't work either. Say if $INSTDIR = &quot;C:\Another folder\Myfolder&quot;, I got a similar error like  &quot;Parsing Failed: Unable to open file folder\Myfolder&quot;. Notice that there is a space between &quot;Another&quot; and &quot;folder&quot;. <br />
<br />
Based on your solution, here is the summary,<br />
<br />
 ExecWait '&quot;$0&quot; &quot;$1&quot; _?=C:\Another folder\Myfolder'<br />
 error msg: Unable to open file folder\Myfolder<br />
<br />
 ExecWait '&quot;$0&quot; &quot;$1&quot; _?=C:\Temp'<br />
 error msg: Unable to open file _?<br />
<br />
 Errors above happen only when the uninstaller($0) takes one parameter. If the uninstaller doesn't take any parameter, it works fine for both cases. Any idea why? Thanks a lot.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">12th May 2011, 23:39</div></div><div class="posttext">I've never encountered that error. I will look in the source code when I can. Just to be sure, it is an NSIS uninstall executable you are running, not some other one?<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">JohnChen</div><div class="date">13th May 2011, 00:05</div></div><div class="posttext">I've never encountered that error. I will look in the source code when I can. Just to be sure, it is an NSIS uninstall executable you are running, not some other one?<br />
<br />
Stu<br />
Yes, I am sure I am running NSIS. Have you ever tried the case where you use ExecWait to run the uninstaller which takes one parameter together with &quot;_?=&quot; option ? Thanks.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">13th May 2011, 11:13</div></div><div class="posttext">Yes I have tried. This works:!include MUI2.nsh<br />
<br />
OutFile TestUninstall.exe<br />
InstallDir $EXEDIR<br />
<br />
!insertmacro MUI_PAGE_INSTFILES<br />
!insertmacro MUI_UNPAGE_INSTFILES<br />
!insertmacro MUI_LANGUAGE English<br />
<br />
Section<br />
<br />
  WriteUninstaller $INSTDIR\un.exe<br />
  ExecWait `&quot;$INSTDIR\un.exe&quot; /a /b _?=$INSTDIR`<br />
  Delete $INSTDIR\un.exe<br />
<br />
SectionEnd<br />
<br />
Section Uninstall<br />
SectionEndStu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">13th May 2011, 11:25</div></div><div class="posttext">I can't find a &quot;Parsing Failed: Unable to open file&quot; in the source code so I highly doubt your uninstall executable is an NSIS one (i.e. generated with WriteUninstaller). NSIS only has a generic &quot;Error launching installer&quot; message. You do realise that _?= is specific to NSIS uninstall executables...<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">JohnChen</div><div class="date">13th May 2011, 11:25</div></div><div class="posttext">Yes I have tried. This works:!include MUI2.nsh<br />
<br />
OutFile TestUninstall.exe<br />
InstallDir $EXEDIR<br />
<br />
!insertmacro MUI_PAGE_INSTFILES<br />
!insertmacro MUI_UNPAGE_INSTFILES<br />
!insertmacro MUI_LANGUAGE English<br />
<br />
Section<br />
<br />
  WriteUninstaller $INSTDIR\un.exe<br />
  ExecWait `&quot;$INSTDIR\un.exe&quot; /a /b _?=$INSTDIR`<br />
  Delete $INSTDIR\un.exe<br />
<br />
SectionEnd<br />
<br />
Section Uninstall<br />
SectionEndStu<br />
Thanks for your reply. But /a or /b is not considered as a parameter of un.exe and they are just switch. A uninstaller with a switch works for me too. The only problem for me is that if a uninstaller takes a parameter. For example, if un.exe needs a file as an input parameter, you would call ExecWait like this,<br />
<br />
ExecWait `&quot;$INSTDIR\un.exe&quot; &quot;$INSTDIR\someFile.txt&quot;  _?=$INSTDIR`<br />
<br />
I wonder if it works for you too? Thanks a lot.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">13th May 2011, 11:29</div></div><div class="posttext">But /a or /b is not considered as a parameter of un.exe and they are just switch.There is no difference between a 'parameter' and a 'switch'. A program simply splits up the tokens on its command line with whitespace as the delimiter. If you tried the code yourself you'd see it works fine substituting /a with &quot;$INSTDIR\someFile.txt&quot;.<br />
<br />
Edit: And the uninstaller doesn't care whether the parameter begins with / or not. It only looks for the first token that begins with _?=, removes that (and proceeding tokens) and then puts the remainder into $CMDLINE which you can use from your uninstall code. It is up to your uninstaller code to handle the parameters from there.<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">JohnChen</div><div class="date">13th May 2011, 11:48</div></div><div class="posttext">There is no difference between a 'parameter' and a 'switch'. A program simply splits up the tokens on its command line with whitespace as the delimiter. If you tried the code yourself you'd see it works fine substituting /a with &quot;$INSTDIR\someFile.txt&quot;.<br />
<br />
Edit: And the uninstaller doesn't care whether the parameter begins with / or not. It only looks for the first token that begins with _?=, removes that (and proceeding tokens) and then puts the remainder into $CMDLINE which you can use from your uninstall code. It is up to your uninstaller code to handle the parameters from there.<br />
<br />
Stu<br />
Before I discuss further, may I ask a simple question? Who is responsible for parsing _?= part? Thanks.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">JohnChen</div><div class="date">13th May 2011, 11:58</div></div><div class="posttext">I can't find a &quot;Parsing Failed: Unable to open file&quot; in the source code so I highly doubt your uninstall executable is an NSIS one (i.e. generated with WriteUninstaller). NSIS only has a generic &quot;Error launching installer&quot; message. You do realise that _?= is specific to NSIS uninstall executables...<br />
<br />
Stu<br />
This is very possible. Thanks for your information.  Actually the uninstaller in question is a third party uninstaller. If this third party uninstaller is not a NSIS one, is there any way to make it work like a NSIS one? Thanks.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">13th May 2011, 12:00</div></div><div class="posttext">_?= is specific to NSIS uninstall executables (i.e. those generated via WriteUninstaller). The NSIS uninstaller, when executed with this option, automatically handles _?= itself. ExecWait does not handle _?= (perhaps this is what you are confused about). You can use _?= via cmd.exe or via a shortcut; it doesn't matter.<br />
<br />
Therefore, you must be trying to execute an uninstall executable which does not know what _?= is (because it's not an NSIS uninstall executable).<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">13th May 2011, 12:02</div></div><div class="posttext">If this third party uninstaller is not a NSIS one, is there any way to make it work like a NSIS one?You'll need to find out what uninstaller it is (i.e. is it Wise, InnoSetup etc.) and determine the correct command line argument to use to prevent it from spawning a new process.<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">JohnChen</div><div class="date">13th May 2011, 14:46</div></div><div class="posttext">_?= is specific to NSIS uninstall executables (i.e. those generated via WriteUninstaller). The NSIS uninstaller, when executed with this option, automatically handles _?= itself. ExecWait does not handle _?= (perhaps this is what you are confused about). You can use _?= via cmd.exe or via a shortcut; it doesn't matter.<br />
<br />
Therefore, you must be trying to execute an uninstall executable which does not know what _?= is (because it's not an NSIS uninstall executable).<br />
<br />
Stu<br />
How can I use WriteUninstaller in a uninstall section?  In a uninstall section functions are expected to have un.. But un.WriteUninstaller is not defined.  Thanks.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">13th May 2011, 14:54</div></div><div class="posttext">Are you getting confused on something else now? Look up WriteUninstaller in the manual. Perhaps you should explain what you are trying to achieve...<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">JohnChen</div><div class="date">13th May 2011, 15:20</div></div><div class="posttext">Are you getting confused on something else now? Look up WriteUninstaller in the manual. Perhaps you should explain what you are trying to achieve...<br />
<br />
Stu<br />
Actually, I was trying to use WriteUninstaller to convert a non-NSIS uninstaller to a NSIS uninstaller. But it doesn't look like it works that way. So if I get a non-NSIS uninstaller, is there any way I can use in NSIS? Thanks.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">13th May 2011, 15:33</div></div><div class="posttext">Well logically you have two options:<br />
<br />
1. Convert the 3rd party uninstaller to NSIS by writing NSIS script<br />
2. Execute the existing one (as you are trying to do)<br />
<br />
The 2nd option is easiest obviously.<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">JohnChen</div><div class="date">13th May 2011, 15:41</div></div><div class="posttext">Well logically you have two options:<br />
<br />
1. Convert the 3rd party uninstaller to NSIS by writing NSIS script<br />
2. Execute the existing one (as you are trying to do)<br />
<br />
The 2nd option is easiest obviously.<br />
<br />
Stu<br />
But if I choose 2nd option, the existing uninstaller doesn't know how to parse _?=. If I choose 1st option, would you please provide me a sample script how to convert  the 3rd party uninstaller to NSIS? Thanks a lot.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">13th May 2011, 15:47</div></div><div class="posttext">As I said before, you need to identify the type of uninstaller and find a suitable switch which does what _?= does in NSIS uninstallers. And I don't mean to write NSIS script to do the conversion lol... you need to follow the tasks the 3rd party uninstaller does and do those tasks in your NSIS uninstall script. Run the 3rd party uninstaller from a sandbox such as Sandboxie. That is what I have done in the past.<br />
<br />
Stu</div></div><hr />


<div class="post"><div class="posttop"><div class="username">JohnChen</div><div class="date">13th May 2011, 18:11</div></div><div class="posttext">There is one related issue with using _?= option. Since _?= stops uninstaller from copying itself to the temporary directory, as the result, the uninstaller couldn't be removed(it couldn't remove itself). Since the uninstaller couldn't be removed, the folder where the uninstaller is located couldn't be removed. I wonder if there is way to keep two good things at the same time. One good thing is allow ExecWait to wait for the uninstaller to finish. Another good thing is still allow users to remove the whole folder where the uninstaller is located.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Afrow UK</div><div class="date">13th May 2011, 18:20</div></div><div class="posttext">Copy the uninstaller to $PLUGINSDIR and then run it from there with _?=$INSTDIR.<br />
<br />
Stu</div></div><hr />


<div id="copyright">2001-2013 <a href="http://creativecommons.org/publicdomain/mark/1.0/" target="_blank">Public Domain Mark 1.0</a></div>
</div>
</body>
</html>