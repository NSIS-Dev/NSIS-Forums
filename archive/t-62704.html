<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="keywords" content=" Idea for better compression, media player, mp3 player, music player, ipod sync, multimedia player, player, winamp, audio player" />
	<meta name="description" content="[Archive]  Idea for better compression NSIS Discussion" />
	
	<title> Idea for better compression [Archive]  - Winamp Forums</title>
	<link rel="stylesheet" type="text/css" href="archive.css" />
</head>
<body>
<div class="pagebody">
<div id="navbar">Winamp Forums &gt; Developer Center &gt; <a href="f-65.html">NSIS Discussion</a> &gt;  Idea for better compression</div>
<hr />
<div class="pda"><a href="t-62704.html?login=1" rel="nofollow">Log in</a></div>
<p class="largefont">Try the Internet Archive: <a href="http://web.archive.org/web/*/forums.winamp.com/showthread.php?t=62704">Idea for better compression</a></p>
<hr />

<div class="post"><div class="posttop"><div class="username">Repzilon</div><div class="date">15th October 2001, 22:44</div></div><div class="posttext">Until now, the datablock optimizer reudces the size of the installer only when the same file is referenced at least twice in the script. But what about almost same files, or files of the same type (example : source files) that have a lot of redundaancy across the files? Why not putting some king of solid archiving ? It would require some kind of sorting, by file extension first, then by filename alphabetically.<br />
<br />
Here is the contents of Rarfiles.lst, a list that RAR/WinRAR uses to sort the files for solid archiving. Sorry for the french header.<br />
<br />
; Liste pour ordonner les fichiers d'une archive solide<br />
;<br />
; Vous pouvez modifier l'ordre de tri que RAR utilise lorsque qu'il ajoute<br />
; des fichiers à une archive solide<br />
;<br />
; Ce fichier peut contenir des noms de fichiers, des caractères génériques<br />
; ou une entrée spéciale : $default. Cette entrée définit la position des<br />
; fichiers qui ne correspondent pas aux autres entrées de ce fichier. Les<br />
; lignes commençant par le symbole &quot;;&quot; sont considérés comme commentaires<br />
; et ne donc pas traités.<br />
;<br />
; Placez ce fichier dans le même répertoire que RAR.EXE.<br />
;<br />
; Astuces pour améliorer le taux et la vitesse de la compression :<br />
;<br />
; - les fichiers contenant des informations similaires devraient être<br />
:   groupés ensemble dans l'archive si possible;<br />
; - les fichiers fréquemment utilisés devraient être placés au début.<br />
;<br />
file_id.diz<br />
descript.ion<br />
read.*<br />
readme.*<br />
*.doc<br />
*.txt<br />
*.htm<br />
*.html<br />
*.shtml<br />
*.lst<br />
*.log<br />
*.ini<br />
*.bat<br />
*.cmd<br />
*.h<br />
*.c<br />
*.cpp<br />
*.asm<br />
*.bas<br />
*.inf<br />
*.bak<br />
*.rtf<br />
*.hlp<br />
*.com<br />
*.exe<br />
*.dll<br />
*.ovr<br />
*.ovl<br />
*.obj<br />
*.lib<br />
*.sys<br />
*.drv<br />
*.bin<br />
*.bmp<br />
*.wav<br />
*.stm<br />
$default<br />
*.gif<br />
*.jpg<br />
*.tif<br />
*.arj<br />
*.ha<br />
*.lzh<br />
*.rar<br />
*.zip<br />
<br />
This kind of list could be easily be put nsisconf.nsi with a parsing similar to InstType. So, we would have in a NSI script, for example :<br />
<br />
FileType &quot;descript.ion&quot;<br />
FileType &quot;read.*&quot;<br />
FileType &quot;readme.*&quot;<br />
FileType &quot;*.doc&quot;<br />
FileType &quot;*.txt&quot;<br />
FileType &quot;*.htm&quot;<br />
FileType &quot;*.html&quot;<br />
FileType &quot;*.shtml&quot;<br />
FileType &quot;*.lst&quot;&quot;<br />
FileType &quot;*.log&quot;<br />
FileType &quot;*.ini&quot;<br />
.<br />
.<br />
.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Koen van de Sande</div><div class="date">16th October 2001, 18:40</div></div><div class="posttext">AFAIK every file in the installer is compressed seperately.<br />
If the files are archived 'solid', you'd have to extract all of them if you're installing (or at least ignore them).<br />
If solid archiving is added, then bzip2 compression will improve for small files too.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">pjw62</div><div class="date">16th October 2001, 19:36</div></div><div class="posttext">what if the dictionary were stored at a different offset and then through some hacking of zlib (I dont know about bzip, I am embarassed to say I haven't used it before), the locations of the compressed file data in the long block were noted instead of the offset to the 'Section'. Then you could extract files ad hoc independently after prepending the dictionary to the raw data with out any modification of the zlib inflate code.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">pjw62</div><div class="date">16th October 2001, 19:41</div></div><div class="posttext">Forgot to add, perhaps as Repzilon inferred, ASCII and binary files could be seperated so as to improve the Huffman weightings in the dictionary and raw data.</div></div><hr />


<div class="post"><div class="posttop"><div class="username">Repzilon</div><div class="date">18th October 2001, 11:14</div></div><div class="posttext">I update my specification.<br />
<br />
First of all, in order to have a faster decompression (because decompressing a part of a solid archive is a pain), instead of being a 100% solid compression, it would be &quot;solid section&quot; compression. I explain. Each section behaves like a separate solid archive, and then, you put them all in the NSIS generated installer.<br />
<br />
My FileType proposition changes a little bit. It is now:<br />
FileType ext_spec ( text | bin )<br />
We can now use the Zlib strategy more efficiently.<br />
<br />
Then, there is parsing code to change. We would have first to sort each instruction for each section, File instructions first. After that, we need to sort the File instructions using the sort key defined with FileType instruction, otherwise, we sort by file type, then by file name.<br />
<br />
Finally, edit the datablock optimizer code to do solid archiving.</div></div><hr />


<div id="copyright">2001-2013 <a href="http://creativecommons.org/publicdomain/mark/1.0/" target="_blank">Public Domain Mark 1.0</a></div>
</div>
</body>
</html>