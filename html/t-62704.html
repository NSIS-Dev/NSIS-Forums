<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Idea for better compression" />

  <title>Idea for better compression - NSIS Forums</title><!-- Bootstrap core CSS -->
  <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/bootswatch/3.0.1/readable/bootstrap.min.css" />
  <link rel="stylesheet" href="../css/style.css" type="text/css" /><!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
                <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
                <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->
</head>

<body>
  <div class="container">
    <!-- Put navigation bar here -->

    <ol class="breadcrumb">
      <li><a href="../index.html" class="glyphicon glyphicon-home"></a></li>

      <li><a href="f-65.html">NSIS Discussion</a></li>

      <li class="active">Idea for better compression</li>
    </ol>

    <p class="lead text-muted">Archive: <a title="Try the Internet Archive" target="_blank" href="http://web.archive.org/web/*/forums.winamp.com/showthread.php?t=62704">Idea for better compression</a></p><br />

    <div class="post">
      <p class="post-meta"><span class="post-author text-primary">Repzilon</span><br />
      <span class="post-time small text-muted">15th October 2001 22:44 <abbr title="Coordinated Universal Time">UTC</abbr></span></p>

      <p class="post-content"><strong>Idea for better compression</strong><br />
      Until now, the datablock optimizer reudces the size of the installer only when the same file is referenced at least twice in the script. But what about almost same files, or files of the same type (example : source files) that have a lot of redundaancy across the file<b>s</b>? Why not putting some king of solid archiving ? It would require some kind of sorting, by file extension first, then by filename alphabetically.<br />
      <br />
      Here is the contents of Rarfiles.lst, a list that RAR/WinRAR uses to sort the files for solid archiving. Sorry for the french header.<br />
      <br />
      ; Liste pour ordonner les fichiers d'une archive solide<br />
      ;<br />
      ; Vous pouvez modifier l'ordre de tri que RAR utilise lorsque qu'il ajoute<br />
      ; des fichiers à une archive solide<br />
      ;<br />
      ; Ce fichier peut contenir des noms de fichiers, des caractères génériques<br />
      ; ou une entrée spéciale : $default. Cette entrée définit la position des<br />
      ; fichiers qui ne correspondent pas aux autres entrées de ce fichier. Les<br />
      ; lignes commençant par le symbole ";" sont considérés comme commentaires<br />
      ; et ne donc pas traités.<br />
      ;<br />
      ; Placez ce fichier dans le même répertoire que RAR.EXE.<br />
      ;<br />
      ; Astuces pour améliorer le taux et la vitesse de la compression :<br />
      ;<br />
      ; - les fichiers contenant des informations similaires devraient être<br />
      : groupés ensemble dans l'archive si possible;<br />
      ; - les fichiers fréquemment utilisés devraient être placés au début.<br />
      ;<br />
      file_id.diz<br />
      descript.ion<br />
      read.*<br />
      readme.*<br />
      *.doc<br />
      *.txt<br />
      *.htm<br />
      *.html<br />
      *.shtml<br />
      *.lst<br />
      *.log<br />
      *.ini<br />
      *.bat<br />
      *.cmd<br />
      *.h<br />
      *.c<br />
      *.cpp<br />
      *.asm<br />
      *.bas<br />
      *.inf<br />
      *.bak<br />
      *.rtf<br />
      *.hlp<br />
      *.com<br />
      *.exe<br />
      *.dll<br />
      *.ovr<br />
      *.ovl<br />
      *.obj<br />
      *.lib<br />
      *.sys<br />
      *.drv<br />
      *.bin<br />
      *.bmp<br />
      *.wav<br />
      *.stm<br />
      $default<br />
      *.gif<br />
      *.jpg<br />
      *.tif<br />
      *.arj<br />
      *.ha<br />
      *.lzh<br />
      *.rar<br />
      *.zip<br />
      <br />
      This kind of list could be easily be put nsisconf.nsi with a parsing similar to InstType. So, we would have in a NSI script, for example :<br />
      <br />
      FileType "descript.ion"<br />
      FileType "read.*"<br />
      FileType "readme.*"<br />
      FileType "*.doc"<br />
      FileType "*.txt"<br />
      FileType "*.htm"<br />
      FileType "*.html"<br />
      FileType "*.shtml"<br />
      FileType "*.lst""<br />
      FileType "*.log"<br />
      FileType "*.ini"<br />
      .<br />
      .<br />
      .</p>
    </div>
    <hr />

    <div class="post">
      <p class="post-meta"><span class="post-author text-primary">Koen van de Sande</span><br />
      <span class="post-time small text-muted">16th October 2001 18:40 <abbr title="Coordinated Universal Time">UTC</abbr></span></p>

      <p class="post-content">AFAIK every file in the installer is compressed seperately.<br />
      If the files are archived 'solid', you'd have to extract all of them if you're installing (or at least ignore them).<br />
      If solid archiving is added, then bzip2 compression will improve for small files too.</p>
    </div>
    <hr />

    <div class="post">
      <p class="post-meta"><span class="post-author text-primary">pjw62</span><br />
      <span class="post-time small text-muted">16th October 2001 19:36 <abbr title="Coordinated Universal Time">UTC</abbr></span></p>

      <p class="post-content">what if the dictionary were stored at a different offset and then through some hacking of zlib (I dont know about bzip, I am embarassed to say I haven't used it before), the locations of the compressed file data in the long block were noted instead of the offset to the 'Section'. Then you could extract files ad hoc independently after prepending the dictionary to the raw data with out any modification of the zlib inflate code.</p>
    </div>
    <hr />

    <div class="post">
      <p class="post-meta"><span class="post-author text-primary">pjw62</span><br />
      <span class="post-time small text-muted">16th October 2001 19:41 <abbr title="Coordinated Universal Time">UTC</abbr></span></p>

      <p class="post-content">Forgot to add, perhaps as Repzilon inferred, ASCII and binary files could be seperated so as to improve the Huffman weightings in the dictionary and raw data.</p>
    </div>
    <hr />

    <div class="post">
      <p class="post-meta"><span class="post-author text-primary">Repzilon</span><br />
      <span class="post-time small text-muted">18th October 2001 11:14 <abbr title="Coordinated Universal Time">UTC</abbr></span></p>

      <p class="post-content">I update my specification.<br />
      <br />
      First of all, in order to have a faster decompression (because decompressing a part of a solid archive is a pain), instead of being a 100% solid compression, it would be "solid section" compression. I explain. Each section behaves like a separate solid archive, and then, you put them all in the NSIS generated installer.<br />
      <br />
      My FileType proposition changes a little bit. It is now:<br />
      FileType ext_spec ( text | bin )<br />
      We can now use the Zlib strategy more efficiently.<br />
      <br />
      Then, there is parsing code to change. We would have first to sort each instruction for each section, File instructions first. After that, we need to sort the File instructions using the sort key defined with FileType instruction, otherwise, we sort by file type, then by file name.<br />
      <br />
      Finally, edit the datablock optimizer code to do solid archiving.</p>
    </div>
    <hr />

    <div class="footer">
      <p class="text-muted small">Fork me on <a href="https://github.com/nsis-dev/NSIS-Forums/">GitHub</a></p>
    </div>
  </div><script src="../js/highlight.pack.js" type="text/javascript">
</script><script type="text/javascript">
//<![CDATA[
  hljs.initHighlightingOnLoad();
  //]]>
  </script>
</body>
</html>
