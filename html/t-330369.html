<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="CRCCheck Failure with uiAccess"><title>CRCCheck Failure with uiAccess - NSIS Forums</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-53539506-8','auto');ga('send','pageview');</script><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/readable/bootstrap.min.css" as="style" onload="this.rel='stylesheet'"><link rel="preload" href="../css/style.css" as="style" onload="this.rel='stylesheet'"><noscript><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/readable/bootstrap.min.css"><link rel="stylesheet" href="../css/style.css"></noscript><script>!function(a){"use strict";var b=function(b,c,d){function e(a){return h.body?a():void setTimeout(function(){e(a)})}function f(){i.addEventListener&&i.removeEventListener("load",f),i.media=d||"all"}var g,h=a.document,i=h.createElement("link");if(c)g=c;else{var j=(h.body||h.getElementsByTagName("head")[0]).childNodes;g=j[j.length-1]}var k=h.styleSheets;i.rel="stylesheet",i.href=b,i.media="only x",e(function(){g.parentNode.insertBefore(i,c?g:g.nextSibling)});var l=function(a){for(var b=i.href,c=k.length;c--;)if(k[c].href===b)return a();setTimeout(function(){l(a)})};return i.addEventListener&&i.addEventListener("load",f),i.onloadcssdefined=l,l(f),i};"undefined"!=typeof exports?exports.loadCSS=b:a.loadCSS=b}("undefined"!=typeof global?global:this);!function(a){if(a.loadCSS){var b=loadCSS.relpreload={};if(b.support=function(){try{return a.document.createElement("link").relList.supports("preload")}catch(b){return!1}},b.poly=function(){for(var b=a.document.getElementsByTagName("link"),c=0;c<b.length;c++){var d=b[c];"preload"===d.rel&&"style"===d.getAttribute("as")&&(a.loadCSS(d.href,d,d.getAttribute("media")),d.rel=null)}},!b.support()){b.poly();var c=a.setInterval(b.poly,300);a.addEventListener&&a.addEventListener("load",function(){b.poly(),a.clearInterval(c)}),a.attachEvent&&a.attachEvent("onload",function(){a.clearInterval(c)})}}}(this);</script></head><body><div class="container"><ol class="breadcrumb"><li><a href="../index.html" class="glyphicon glyphicon-home"></a></li><li><a href="f-65.html">NSIS Discussion</a></li><li class="active">CRCCheck Failure with uiAccess</li></ol><p class="lead text-muted">Archive: <a title="Try the Internet Archive" target="_blank" href="http://web.archive.org/web/*/forums.winamp.com/showthread.php?t=330369">CRCCheck Failure with uiAccess</a></p><br><div class="post"><p class="post-meta"><span class="post-author text-primary">JasSays</span><br><span class="post-time small text-muted">6th May 2011 10:18 <abbr title="Coordinated Universal Time">UTC</abbr></span></p><p class="post-content"><strong>CRCCheck Failure with uiAccess</strong><br>In my NSIS install, my application is ran a few times, during update to check various processes, look for a mutex, and while uninstalling for the same and for cleanup. The problem is, my application is an accessibility application with uiAccess="true" in the manifest. This is a requirement and cannot be changed. The problem is, NSIS fails to run my application due to this, I have changed the installer to use uiAccess and digitally signed the install however this causes a CRC check failure:<br><br>"Install integrity check has failed. Common causes include incomplete download and damaged media. Contact the installer's author to obtain a new copy."<br><br>I have also turned off CRCCheck:<br>CRCCheck off<br><br>Which appears to have no effect, any thoughts? Am I going about this the wrong way? Is there another way to launch accessibility applications? With uiAccess="true" my application fails to even start at the end of install.<br><br>Edit:<br>I noticed that using nsExec::Exec returns "error", is there any way to find out what error exactly is received? The file exists and runs like normal if uiAccess="false".</p></div><hr><div class="post"><p class="post-meta"><span class="post-author text-primary">Afrow UK</span><br><span class="post-time small text-muted">6th May 2011 14:09 <abbr title="Coordinated Universal Time">UTC</abbr></span></p><p class="post-content">Try with ExecDos. Its exit code has some defined values which correspond to the GetLastError API (you need to look at the source code).<br><br>Stu</p></div><hr><div class="post"><p class="post-meta"><span class="post-author text-primary">JasSays</span><br><span class="post-time small text-muted">6th May 2011 14:55 <abbr title="Coordinated Universal Time">UTC</abbr></span></p><p class="post-content">Thanks for the reply, that got me an exit code: -14. Looking through the source of execDos, it looks like error ERR_CREATEPROC, I don't see it call GetLastError in there although my c++ is a bit rusty.<br><br>Edit: This got me thinking, in the source of ExecDos it looks like it redirects standard output. I've now wrote an application which takes command line arguments and redirects them to another process. It validates that the process and destination contain the same public keys for security and it is running with uiAccess=false. It can successfully query the app and return the exit code to NSIS.<br><br>NSIS:<br>nsExec::Exec '"$INSTDIR\Invoker.exe" -TARGET:"$INSTDIR\App.exe" -SOMEFLAGS'<br><br>Invoker then runs the TARGET with the specified flags and returns the exit code as it's own. I would rather use NSIS instead of this convoluted process however, any thoughts?</p></div><hr><div class="post"><p class="post-meta"><span class="post-author text-primary">Anders</span><br><span class="post-time small text-muted">6th May 2011 16:15 <abbr title="Coordinated Universal Time">UTC</abbr></span></p><p class="post-content">You must use ExecShell to start applications with Vista manifests...<br><br>Signing a NSIS installer is a bit hard, you can't just sign it after makensis has completed, it must happen during the build phase.</p></div><hr><div class="post"><p class="post-meta"><span class="post-author text-primary">JasSays</span><br><span class="post-time small text-muted">6th May 2011 17:19 <abbr title="Coordinated Universal Time">UTC</abbr></span></p><p class="post-content"></p><blockquote><small>Originally posted by Anders</small><br>You must use ExecShell to start applications with Vista manifests...<br><br>Signing a NSIS installer is a bit hard, you can't just sign it after makensis has completed, it must happen during the build phase.</blockquote>Can ExecShell wait until the process has completed and return an exit code? I know it's not a coding limitation as my own implimentation outside of NSIS works. My application does not create a window and simply returns one of several exit codes as a query. Both the installer and uninstaller are signed.</div><hr><div class="post"><p class="post-meta"><span class="post-author text-primary">Afrow UK</span><br><span class="post-time small text-muted">6th May 2011 17:30 <abbr title="Coordinated Universal Time">UTC</abbr></span></p><p class="post-content"></p><blockquote><small>Originally posted by Anders</small><br>Signing a NSIS installer is a bit hard, you can't just sign it after makensis has completed, it must happen during the build phase.</blockquote>We've been signing after build has completed without any issues. Haven't disabled CRC check. What are the reasons for signing the exehead rather than the entire installer?<br><br>Edit: @JasSays if it doesn't create a window, why are you using nsExec? Have you tried ExecWait? ExecShell (ShellExecute) cannot wait.<br><br>Stu</div><hr><div class="post"><p class="post-meta"><span class="post-author text-primary">JasSays</span><br><span class="post-time small text-muted">6th May 2011 17:58 <abbr title="Coordinated Universal Time">UTC</abbr></span></p><p class="post-content"></p><blockquote><small>Originally posted by Afrow UK</small><br>We've been signing after build has completed without any issues. Haven't disabled CRC check. What are the reasons for signing the exehead rather than the entire installer?<br><br>Edit: @JasSays if it doesn't create a window, why are you using nsExec? Have you tried ExecWait? ExecShell (ShellExecute) cannot wait.<br><br>Stu</blockquote>I've tried all the above and they all fail with either null exit code or a "error" result (except ExecShell, but that does not wait). I think it has to do with the application having a manifest with uiAccess="true" and that causes NSIS to fail to run it under all of NSIS' methods. Granted, needing ui access is rare so I'm not surprised no one else has ran into this. Now I'm using this method:<br><br>NSIS installs application.exe with the following execution level:<br>&lt;requestedExecutionLevel level="asInvoker" uiAccess="true" /&gt;<br><br>and invoker.exe which has this requested execution level:<br>&lt;requestedExecutionLevel level="requireAdministrator" uiAccess="false" /&gt;<br><br>Before installing, NSIS does this:<br>ExecWait '"$INSTDIR\invoker.exe" -TARGET:"$INSTDIR\application.exe" -FLAGS' $0<br>...<br><br>invoker.exe boots up application.exe with shell but also waits for it to complete:<br><pre>
<code> <br>static void Main(string[] sargs)<br>{<br>        .....<br>        using (Process p = CreateProcess(targetApplication, true, [flag]))<br>        {<br>                WaitForProcess(p);<br>                Environment.ExitCode = p.ExitCode;<br>        }<br>        .....<br>}<br>private static Process CreateProcess(string filename, bool showWindow, string arguments)<br>        {<br>            ProcessStartInfo psi = new ProcessStartInfo();<br>            psi.Arguments = arguments;<br>            psi.FileName = filename;<br>            psi.WorkingDirectory = Path.GetDirectoryName(filename);<br>            psi.UseShellExecute = true;<br>            if (!showWindow)<br>                psi.WindowStyle = ProcessWindowStyle.Hidden;<br>            return Process.Start(psi);<br>        }<br><br>        private static void WaitForProcess(Process p)<br>        {<br>            using (ManualResetEventSlim reset = new ManualResetEventSlim(false))<br>            {<br>                while (!p.HasExited)<br>                {<br>                    reset.Wait(100);<br>                }<br>            }<br>        }<br></code>
</pre><br>
      <br>
      This appears to work and is providing the correct results. However I would love there to be a way without using another process.
    </div>
    <hr>

    <div class="post">
      <p class="post-meta"><span class="post-author text-primary">Afrow UK</span><br>
      <span class="post-time small text-muted">6th May 2011 18:11 <abbr title="Coordinated Universal Time">UTC</abbr></span></p>

      <p class="post-content">You need to call ShellExecuteEx directly if you need to wait (sorry I should have said this earlier). This is what Process.Start (with UseShellExecute = true) uses underneath. You can call ShellExecuteEx with the System plug-in. The filled in SHELLEXECUTEINFO struct has a hProcess member which you can use WaitForSingleObject API on followed by GetExitCodeProcess.<br>
      <br>
      Btw why are you using a ManualResetEventSlim in your .NET program? Why not just use Thread.Sleep(100) or simpler, use p.WaitFor Exit()?<br>
      <br>
      Stu</p>
    </div>
    <hr>

    <div class="post">
      <p class="post-meta"><span class="post-author text-primary">JasSays</span><br>
      <span class="post-time small text-muted">6th May 2011 18:29 <abbr title="Coordinated Universal Time">UTC</abbr></span></p>

      <p class="post-content"></p>

      <blockquote>
        <small>Originally posted by Afrow UK</small><br>
        You need to call ShellExecuteEx directly if you need to wait (sorry I should have said this earlier). This is what Process.Start (with UseShellExecute = true) uses underneath. You can call ShellExecuteEx with the System plug-in. The filled in SHELLEXECUTEINFO struct has a hProcess member which you can use WaitForSingleObject API on followed by GetExitCodeProcess.<br>
        <br>
        Btw why are you using a ManualResetEventSlim in your .NET program? Why not just use Thread.Sleep(100) or simpler, use p.WaitFor Exit()?<br>
        <br>
        Stu
      </blockquote>Thanks for your reply, that's exactly what I wanted. :up:<br>
      <br>
      Oh and the reason for the wait handle is there is other functionality that I have left out of the example, the ability to stop waiting, time out, and other functions. Some argue using a wait handle instead of Sleep is more predictable/consistant at the expense of resources. For me, I just like the added functionality. For the purpose of my example it is redundant.
    </div>
    <hr>

    <div class="post">
      <p class="post-meta"><span class="post-author text-primary">Anders</span><br>
      <span class="post-time small text-muted">6th May 2011 21:38 <abbr title="Coordinated Universal Time">UTC</abbr></span></p>

      <p class="post-content"><a href="http://nsis.sourceforge.net/ShellExecWait" target="_blank">http://nsis.sourceforge.net/ShellExecWait</a></p>
    </div>
    <hr>

    <div class="post">
      <p class="post-meta"><span class="post-author text-primary">JasSays</span><br>
      <span class="post-time small text-muted">7th May 2011 06:14 <abbr title="Coordinated Universal Time">UTC</abbr></span></p>

      <p class="post-content"></p>

      <blockquote>
        <small>Originally posted by Anders</small><br>
        <a href="http://nsis.sourceforge.net/ShellExecWait" target="_blank">http://nsis.sourceforge.net/ShellExecWait</a>
      </blockquote>Thank you! That solved my problem and works perfectly.
    </div>
    <hr>

    <div class="footer">
      <p class="text-muted small">Fork me on <a href="https://github.com/nsis-dev/NSIS-Forums/">GitHub</a></p>
    </div>
  </div><script type="text/javascript" src="../js/highlight.pack.js" async>
</script><script type="text/javascript">
//<![CDATA[
  hljs.initHighlightingOnLoad();
  //]]></script></body></html>